#+TITLE: Go

* Basics
** Hello world

#+begin_src go :exports both
package main

import "fmt"

func main() {
    fmt.Println("Hello world")
}
#+end_src

#+RESULTS:
: Hello world

** Paquetes
- Todo programa de go esta hecho de paquetes (=package=).
- Siempre se empieza con el paquete =main=.

#+begin_src go
package main
#+end_src

** =Imports=
- Además del paquete =main=.
  + Go tiene diferentes paquetes que pueden ser importados.
- El más común es el paquete =fmt=.
  + =fmt= es por la palabra =format=, y nos da la habilidad de hacer =Imput= y =Output= de manera fácil.

#+begin_src go
import (
	"fmt"
	"math"
)
#+end_src

#+begin_quote
Se pueden importar varios paquetes a la vez poniéndolos entre paréntesis.
#+end_quote

- Cada paquete tiene palabras claves las cuales pueden ser usadas después de importar el paquete.
  + Cada una de estas palabras siempre empieza con mayúscula.
- En el ejemplo de arriba accedimos a la palabra clave (método) =Println=.
  + Este escribe texto en la consola.

#+begin_quote
Similar a otros lenguajes =func main()= es el punto de entrada del programa.
#+end_quote

** Comentarios
- Podemos poner en nuestro código comentarios.
  + Esto se hace poniendo =//=, para un comentario de una sola linea.
  + Los comentarios multilínea se hacen rodeando el texto con =/* */=.

#+begin_src go
// comentario de una sola linea
fmt.Println("go go go go!")
/* comentario
   multilínea */
#+end_src

* Conceptos básicos
** Variables
- Se usan para guardar valores.
- Se usa la palabra clave =var= para declararlas.

#+begin_src go
var i int // var <nombre de la variable> <tipo>
#+end_src

#+begin_src go
var i int = 8 // var <nombe> <tipo> = <valor de la variable>
fmt.print(i)
#+end_src

- También podemos asignar múltiples variables en una sola linea.
- Go tiene inferencia de tipos.
  + Esto significa que Go puede adivinar el tipo de la variable si a esta le es asignada un valor.

#+begin_src go
var i, j = 69, 42 // Go sabe que i y j son int (enteros)
#+end_src

- Go soporta asignación corta de variables.

#+begin_src go
i := 8
x, y, z := 1, 2, 3
#+end_src

#+begin_quote
Este operador automáticamente define e inicializa las variables.
#+end_quote

** Tipos de datos
- Los tipos de dato más comunes en go son:
  + =float32=
  + =float64=
  + =string=
  + =bool=

#+begin_quote
La diferencia entre =float32= y =float64= es la precisión, =float64= representara el número con mayor precisión en los decimales.
#+end_quote

- Go también posee =zero values= (valores cero).
  + Son variables que son inicializadas sin un valor y toman el valor 0 de ese valor.
    - 0 para los entero.
    - =false= para los booleanos.
    - =""= para los =strings=.

** Constantes
- Las constantes son valores que no pueden cambiar su valor inicial.
- Son declaradas como las variables pero usando la palabra clave =const=.
- No pueden ser declaradas con la sintaxis =:.

#+begin_src go
const pi = 3.14
#+end_src

** Obteniendo =input=
- Necesitamos el paquete =fmt=.

#+begin_src go
var input string
fmt.Scanln(&input)

fmt.Println(input)
#+end_src

#+begin_quote
El carácter =&= es usado para retornar la dirección de la variable.
#+end_quote

#+begin_src go
var input int
fmt.Scanln(&input)

fmt.Println(input)
#+end_src

#+begin_quote
En este ejemplo como declaramos la variable =input= como =int= go convertirá el input a un =int=.
#+end_quote

** =if/else=
- Se usa para hacer decisiones.

#+begin_src go
x := 69

if x != 69 {
	fmt.Println("Not funny!")
}
else {
	fmt.Println("Maybe funny!")
}
#+end_src

#+begin_quote
El código dentro de los corchetes no correrá a menos que la condición se cumpla.
#+end_quote

- Es posible declarar una variable en el =if= si es que lo necesitas.

#+begin_src go
if x := 42; x > 18 { // se usa el ; para separar las dos operaciones.
	fmt.Println("Sup!")
}
else {
	fmt.Println("Sup'n!")
}
#+end_src

** =switch=
- Un =switch= es una manera más corta de hacer una secuencia de =if/else=.

#+begin_src go
num := 3

switch num {
case 1:
	fmt.Println("1")
case 2:
	fmt.Println("2")
case 3:
	fmt.Println("3")
default:
	fmt.Println(num)
}
#+end_src

- también podemos usar condiciones en los =case=.

#+begin_src go
num := 3

switch num {
	case num > 0 && x < 10:
	fmt.Println("algo")
	case num > 10:
	fmt.Println("otra cosa")
}
#+end_src

#+begin_quote
Al igual que los =if/else=, el =switch= puede tener una declaración de variable antes de las expresiones condicionales.
#+end_quote

** ciclos
- El único ciclo en Go es el ciclo =for=.
  + Este se compone de el inicio, la condición y el incremento.

#+begin_src go
for i := 0; i < 5 ; i++ {
	fmt.Println(i)
}
#+end_src

- Sin embargo podemos omitir el inicio y el incremento para hacerlo parecido a un =while=.

#+begin_src go
sum := 1
res := 0

for sum < = 1000 {
	res += sum
	sum ++
}
fmt.Println(res)
#+end_src

* Funciones
** Introducción a funciones
- Nos permiten definir un bloque de código que podemos llamar después.
- Nos permiten reusar código.
- se usa la palabra =func= para definir funciones.

#+begin_src go
func welcome() {
	fmt.Println("hello")
}
#+end_src

#+begin_quote
Hemos definido una función llamada =welcome= que imprime =Hello= en la consola.
#+end_quote

#+begin_src go
func main() {
	welcome()
	welcome()
}
#+end_src

#+begin_quote
Ahora podemos llamar a esa función cuantas veces queramos.
#+end_quote

** Argumentos
- Son una manera de pasarle información a las funciones.
- Los argumentos se comportan como una variable dentro de el cuerpo de la función.
- Cuando llamemos a esta función debemos darle los argumentos que le hayamos puesto a la función.

#+begin_src go
func welcome(name string) {
	fmt.Println("hello,"+name)
}

func main() {
	welcome("david")
	welcome("james")
}
#+end_src

#+begin_quote
En go el tipo del argumento va después de el nombre del argumento.
#+end_quote

** Argumentos múltiples
- Para hacer que una función acepte múltiples argumentos usamos comas.

#+begin_src go
func sum(a int, b int) {
	fmt.Println(a+b)
}

func main() {
	sum(5,5)
}
#+end_src

#+begin_quote
Si todos los argumentos son del mismo tipo podemos definir el tipo en el último ej. =sum(a, b, c int)=
#+end_quote

** =return=
- A veces vamos a querer que nuestras funciones retornen valores.
- Para eso ocupamos la palabra =return=.
  + Este termina la función y retorna el valor dado.

#+begin_src go
func sum(x, y int) int {
	return x + y
}

func main() {
	result := sum(4, 5)
}
#+end_src

#+begin_quote
Debemos definir el tipo de dato del retorno fuera de los argumentos de la función, en este caso es =int=.
#+end_quote

** Múltiples =return=
- En go podemos retornar múltiples valores de una función.

#+begin_src go
func swap(x, y int) (int, int) {
	return y, x
}
#+end_src

#+begin_quote
Al igual que retornando un solo valor, debemos declarar los tipos de los valores a retornar.
#+end_quote

** =Defer=
- La palabra =defer= se asegura de que una función es llamada solo después de que la función en la que se encuentra termine o retorne.

#+begin_src go :results both
import "fmt"

func welcome() {
	fmt.Println("welcome")
}

func main() {
	defer welcome()
	fmt.Println("Hey")
}
#+end_src

#+RESULTS:
: Hey
: welcome

En este caso, no se llama a =welcome= hasta que se haya terminado de ejecutar =fmt.Println("Hey")=.

#+begin_quote
=defer= es usado normalmente para limpiar recursos, por ejemplo para liberar memoria usada por el código como archivos, conexiones, etc.
#+end_quote

** Múltiples =defer=
- Si se usan múltiples =defer=, estas serán ejecutadas en orden =last-in-first-out=.
  + Tal como si fueran una pila.

#+begin_src go :exports both
import "fmt"

func main() {
	fmt.Println("start")

	for i := 0; i < 5; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("end")
}

#+end_src

#+RESULTS:
: start
: end
: 4
: 3
: 2
: 1
: 0

** Alcance
- El alcance (scope) es el donde una variable puede ser usada.
- Hay dos alcances principales en go =local= y =global=.
- Una variable definida en una función es local, su alcance existe solo dentro de esa función, afuera no existe.
- Una variable definida fuera de la función es llamada global y pueden ser usadas en todo el =package=.

#+begin_src go
var x = 8 // global

func test() {
	var y = 9 // local
	fmt.Println(x)
}

func main() {
	fmt.Println(x)
}
#+end_src

#+begin_quote
Variables globales son normalmente consideradas mala práctica, es mejor pasar variables como argumentos.
#+end_quote

* Punteros y =structs=
** Punteros
- Todos los valores que definimos en nuestro programa son guardados en la memoria y tienen su dirección de memoria única.
- Los punteros son variables especiales que guardan la dirección de memoria de un valor.
- En go nos referimos a un puntero con =*=.

#+begin_src go
var p *int
#+end_src

p es un puntero a un valor tipo =int=.

#+begin_quote
Los punteros permiten pasar referencias a valores en tu programa.
#+end_quote

- A los punteros les asignaos una dirección de memoria usando el operador =&=.

#+begin_src go
x := 42
p := &x
#+end_src

Ahora =p= es un puntero y mantiene la dirección de memoria de x.

#+begin_src go :exports both
package main

import "fmt"

func main() {
  x := 42
  p := &x
  fmt.Println(p)
}
#+end_src

#+RESULTS:
: 0xc0000ba000

Si queremos acceder al valor de el puntero, podemos usar el operador =*=.

#+begin_src go
package main

import "fmt"

func main() {
  x := 42
  p := &x
  fmt.Println(*p)
}
#+end_src

#+RESULTS:
: 42

El operador =*= puede ser usado para cambiar el valor de la dirección de memoria que del puntero.

#+begin_src go :exports both
package main

import "fmt"

func main() {
  x := 42
  p := &x

  *p = 8
  fmt.Println(*p)
  fmt.Println(x)
}
#+end_src

#+RESULTS:
: 8
: 8

#+begin_quote
Somos capaces de  cambiar el valor de x usando el puntero =p=.
#+end_quote

** Pasando punteros a funciones
- Para leer texto de la consola hemos usado punteros.

#+begin_src go
package main

import "fmt"

func main() {
  var input string
  fmt.Scanln(&input)

  fmt.Println(input)
}
#+end_src

#+begin_quote
Aquí pasábamos la dirección de memoria de la variable =input= a la función =Scanln=.
#+end_quote

Podemos pasar punteros como parametros de una función.

#+begin_src go :exports both
package main

import "fmt"

func change(val int) {
  val = 8
}

func change_ptr(ptr *int) {
  *ptr = 8
}

func main() {
  x := 42

  change(x)
  fmt.Println(x)

  change_ptr(&x)
  fmt.Println(x)
}
#+end_src

#+RESULTS:
: 42
: 8

- La función =change()= toma como parametro un =int= y cambia su valor.
- La función =change_ptr()= hace lo mismo, pero toma como argumento un puntero a un =int=.

#+begin_quote
La =change()= no cambio el valor de x porque el argumento es una copia de x y =change_ptr()= si lo cambio porque le pasamos la dirección de memoria de x.
#+end_quote

** =Structs=
- Go no soporta clases, en su lugar tiene =structs=.

#+begin_src go
type Contact struct {
  name string
  age  int
}
#+end_src

Nuestro contacto tiene dos campos, nombre y edad.

Ahora podemos crear un nuevo contacto.

#+begin_src go
x := Contract{ "James", 42 }
#+end_src

=x= es ahora un =struct= que ha sido inicializado con los valores anteriores.

También podemos darle el nombre de los campos a la hora de crearlo.

#+begin_src go
x := Contact{name: "James", age: 42}
#+end_src

Podemos acceder a los campos del =struct= de la siguiente manera.

#+begin_src go :exports both
package main

import "fmt"

type Contact struct {
  name string
  age int
}

func main() {
  x := Contact{"James", 42}

  x.age = 8
  fmt.Println(x.age)
  fmt.Println(x.name)
}
#+end_src

#+RESULTS:
: 8
: James

** Punteros a =Structs=
De manera similar a punteros simples, podemos hacer punteros a =structs=.

#+begin_src go
x := Contact{"James", 42}
p := &x
#+end_src

#+begin_src go :exports both
package main

import "fmt"

type Contact struct {
  name string
  age int
}

func main() {
  x := Contact{"James", 42}
  p := &x

  fmt.Println(p.age)
}
#+end_src

#+RESULTS:
: 42

#+begin_quote
Podríamos acceder a =p= con =(*p).age= pero go nos permite hacerlo con solo =p.age=.
#+end_quote

También podemos usar punteros cuando creamos un nuevo =struct=.

#+begin_src go :exports both
package main

import "fmt"

type Contact struct {
  name string
  age int
}

func main() {
  p := &Contact{"John", 15}

  fmt.Println(p.name)
}
#+end_src

#+RESULTS:
: John

Ahora =p= es un puntero a el =struct= que se acaba de crear.

** Métodos
- Podemos agregarle funcionalidad a nuestros =structs= añadiendoles métodos.
- Los métodos son simplemente funciones con un argumento recibidor adicional.

#+begin_src go
func (x Contact) welcome() {
  fmt.Println(x.name)
  fmt.Println(x.age)
}
#+end_src

#+begin_quote
El argumento recibidor va entre el nombre del método y la palabra =func=.
#+end_quote

Después de definir un método podemos acceder a el con la sintaxis punto.

#+begin_src go
package main

import "fmt"

type Contact struct {
  name string
  age int
}

func (x Contact) welcome() {
  fmt.Println(x.name)
  fmt.Println(x.age)
}

func main() {
  x := Contact{"James", 42}
  x.welcome()
}
#+end_src

#+RESULTS:
: James
: 42

Como los métodos son solo funciones con un argumento recibidor, podemos alcanzar la misma funcionalidad usando una función regular que toma un =struct= como parametro.

#+begin_src go :exports both
package main

import "fmt"

type Contact struct {
  name string
  age int
}

func welcome(x Contact) {
  fmt.Println(x.name)
  fmt.Println(x.age)
}
func main() {
  x := Contact{"James", 42}
  welcome(x)
}
#+end_src

#+RESULTS:
: James
: 42

En el caso de que necesitemos cambiar los datos del =struct= en un método podemos usar punteros.

#+begin_src go
func (ptr *Contact) increase(val int) {
  ptr.age += val
}
#+end_src

El método =increase()= usa un puntero como argumento y puede modificar el campo de =age= del =struct=.

#+begin_src go :exports both
package main

import "fmt"

type Contact struct {
  name string
  age int
}

func (ptr *Contact) increase(val int) {
  ptr.age += val
}

func main() {
  x := Contact{"James", 42}
  x.increase(8)
  fmt.Println(x.age)
}
#+end_src

#+RESULTS:
: 50
