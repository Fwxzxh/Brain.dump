<!doctype html>
<html lang="en">
<head>
<title>C#</title>
<!-- 2022-01-30 Sun 21:51 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Org-mode">
<meta name="author" content="J.D Castro">

<link  href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
<style>
/* org mode styles on top of twbs */

html {
    position: relative;
    min-height: 100%;
}

body {
    font-size: 18px;
    margin-bottom: 105px;
}

footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 101px;
    background-color: #f5f5f5;
}

footer > div {
    padding: 10px;
}

footer p {
    margin: 0 0 5px;
    text-align: center;
    font-size: 16px;
}

#table-of-contents {
    margin-top: 20px;
    margin-bottom: 20px;
}

blockquote p {
    font-size: 18px;
}

pre {
    font-size: 16px;
}

.footpara {
    display: inline-block;
}

figcaption {
  font-size: 16px;
  color: #666;
  font-style: italic;
  padding-bottom: 15px;
}

/* from twbs docs */

.bs-docs-sidebar.affix {
    position: static;
}
@media (min-width: 768px) {
    .bs-docs-sidebar {
        padding-left: 20px;
    }
}

/* All levels of nav */
.bs-docs-sidebar .nav > li > a {
    display: block;
    padding: 4px 20px;
    font-size: 14px;
    font-weight: 500;
    color: #999;
}
.bs-docs-sidebar .nav > li > a:hover,
.bs-docs-sidebar .nav > li > a:focus {
    padding-left: 19px;
    color: #A1283B;
    text-decoration: none;
    background-color: transparent;
    border-left: 1px solid #A1283B;
}
.bs-docs-sidebar .nav > .active > a,
.bs-docs-sidebar .nav > .active:hover > a,
.bs-docs-sidebar .nav > .active:focus > a {
    padding-left: 18px;
    font-weight: bold;
    color: #A1283B;
    background-color: transparent;
    border-left: 2px solid #A1283B;
}

/* Nav: second level (shown on .active) */
.bs-docs-sidebar .nav .nav {
    display: none; /* Hide by default, but at >768px, show it */
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 30px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav > li > a:focus {
    padding-left: 29px;
}
.bs-docs-sidebar .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav > .active:focus > a {
    padding-left: 28px;
    font-weight: 500;
}

/* Nav: third level (shown on .active) */
.bs-docs-sidebar .nav .nav .nav {
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 40px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav .nav > li > a:focus {
    padding-left: 39px;
}
.bs-docs-sidebar .nav .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav .nav > .active:focus > a {
    padding-left: 38px;
    font-weight: 500;
}

/* Show and affix the side nav when space allows it */
@media (min-width: 992px) {
    .bs-docs-sidebar .nav > .active > ul {
        display: block;
    }
    /* Widen the fixed sidebar */
    .bs-docs-sidebar.affix,
    .bs-docs-sidebar.affix-bottom {
        width: 213px;
    }
    .bs-docs-sidebar.affix {
        position: fixed; /* Undo the static from mobile first approach */
        top: 20px;
    }
    .bs-docs-sidebar.affix-bottom {
        position: absolute; /* Undo the static from mobile first approach */
    }
    .bs-docs-sidebar.affix .bs-docs-sidenav,.bs-docs-sidebar.affix-bottom .bs-docs-sidenav {
        margin-top: 0;
        margin-bottom: 0
    }
}
@media (min-width: 1200px) {
    /* Widen the fixed sidebar again */
    .bs-docs-sidebar.affix-bottom,
    .bs-docs-sidebar.affix {
        width: 263px;
    }
}
</style>
<script>
$(function() {
    'use strict';

    $('.bs-docs-sidebar li').first().addClass('active');

    $(document.body).scrollspy({target: '.bs-docs-sidebar'});

    $('.bs-docs-sidebar').affix();
});
</script><style>pre { font-size: 16px; background-color: #2E3440; color: #bbb; }</style>
</head>
<body>
<div id="content" class="container">
<div class="row"><div class="col-md-3 col-md-push-9"><nav id="table-of-contents">
<div id="text-table-of-contents" class="bs-docs-sidebar">
<ul class="nav">
<li><a href="#sec-1">1. Conceptos Básicos</a>
<ul class="nav">
<li><a href="#sec-1-1">1.1. C#</a></li>
<li><a href="#sec-1-2">1.2. .NET Framework</a></li>
<li><a href="#sec-1-3">1.3. Variables</a></li>
<li><a href="#sec-1-4">1.4. Tipos de variables</a></li>
<li><a href="#sec-1-5">1.5. Tipos de datos</a></li>
<li><a href="#sec-1-6">1.6. Mi primer programa en C#</a></li>
<li><a href="#sec-1-7">1.7. Mostrando texto</a></li>
<li><a href="#sec-1-8">1.8. Leyendo texto</a></li>
<li><a href="#sec-1-9">1.9. Comentarios</a></li>
<li><a href="#sec-1-10">1.10. La palabra <code>var</code></a></li>
<li><a href="#sec-1-11">1.11. Constantes</a></li>
<li><a href="#sec-1-12">1.12. Operadores Aritméticos</a></li>
<li><a href="#sec-1-13">1.13. Operadores de asignación e incremento</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Condicionales y loops</a>
<ul class="nav">
<li><a href="#sec-2-1">2.1. <code>if else</code></a></li>
<li><a href="#sec-2-2">2.2. operador <code>switch</code></a></li>
<li><a href="#sec-2-3">2.3. El ciclo <code>while</code></a></li>
<li><a href="#sec-2-4">2.4. El ciclo <code>for</code></a></li>
<li><a href="#sec-2-5">2.5. <code>do-while</code></a></li>
<li><a href="#sec-2-6">2.6. <code>break</code> y <code>continue</code></a></li>
<li><a href="#sec-2-7">2.7. Operadores lógicos</a></li>
<li><a href="#sec-2-8">2.8. El operador condicional</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Métodos</a>
<ul class="nav">
<li><a href="#sec-3-1">3.1. Introducción a los métodos</a></li>
<li><a href="#sec-3-2">3.2. Declarando métodos</a></li>
<li><a href="#sec-3-3">3.3. Llamando a métodos</a></li>
<li><a href="#sec-3-4">3.4. Parametros</a></li>
<li><a href="#sec-3-5">3.5. Pasando argumentos</a></li>
<li><a href="#sec-3-6">3.6. Sobrecarga</a></li>
<li><a href="#sec-3-7">3.7. Recursividad</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Clases y objetos</a>
<ul class="nav">
<li><a href="#sec-4-1">4.1. Clases</a></li>
<li><a href="#sec-4-2">4.2. Objetos</a></li>
<li><a href="#sec-4-3">4.3. Valor y tipos de referencia</a></li>
<li><a href="#sec-4-4">4.4. Clases</a></li>
<li><a href="#sec-4-5">4.5. Encapsulación</a></li>
<li><a href="#sec-4-6">4.6. Constructores</a></li>
<li><a href="#sec-4-7">4.7. Propiedades</a></li>
<li><a href="#sec-4-8">4.8. Propiedades auto implementadas.</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Arreglos y Cadenas</a>
<ul class="nav">
<li><a href="#sec-5-1">5.1. Arreglos</a></li>
<li><a href="#sec-5-2">5.2. Usando arreglos en ciclos</a></li>
<li><a href="#sec-5-3">5.3. Arreglos multidimencionales</a></li>
<li><a href="#sec-5-4">5.4. Arreglos dentados</a></li>
<li><a href="#sec-5-5">5.5. Propiedades de los arreglos y métodos</a></li>
<li><a href="#sec-5-6">5.6. Trabajando con cadenas</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Más sobre clases</a>
<ul class="nav">
<li><a href="#sec-6-1">6.1. Destructores</a></li>
<li><a href="#sec-6-2">6.2. Miembros estáticos</a></li>
<li><a href="#sec-6-3">6.3. <code>This</code> &amp; <code>readonly</code></a></li>
<li><a href="#sec-6-4">6.4. Indexadores</a></li>
<li><a href="#sec-6-5">6.5. Sobrecarga de Operadores</a></li>
</ul>
</li>
<li><a href="#sec-7">7. Herencia y polimorfismo</a>
<ul class="nav">
<li><a href="#sec-7-1">7.1. Herencia</a></li>
<li><a href="#sec-7-2">7.2. Miembros protegidos</a></li>
<li><a href="#sec-7-3">7.3. Sellado</a></li>
<li><a href="#sec-7-4">7.4. Constructor y destructor de la clase derivada.</a></li>
<li><a href="#sec-7-5">7.5. Poliformismo</a></li>
<li><a href="#sec-7-6">7.6. Clases abstractas</a></li>
<li><a href="#sec-7-7">7.7. Interfaces</a></li>
<li><a href="#sec-7-8">7.8. Clases anidadas</a></li>
<li><a href="#sec-7-9">7.9. <code>namespaces</code></a></li>
</ul>
</li>
<li><a href="#sec-8">8. <code>Structs</code>, <code>Enums</code>, Excepciones &amp; Archivos</a>
<ul class="nav">
<li><a href="#sec-8-1">8.1. <code>Structs</code></a></li>
<li><a href="#sec-8-2">8.2. <code>Enums</code></a></li>
<li><a href="#sec-8-3">8.3. Manejo de excepciones</a></li>
<li><a href="#sec-8-4">8.4. Trabajando con archivos</a></li>
</ul>
</li>
<li><a href="#sec-9">9. Genéricos</a>
<ul class="nav">
<li><a href="#sec-9-1">9.1. Genéricos</a></li>
<li><a href="#sec-9-2">9.2. Métodos Genéricos</a></li>
<li><a href="#sec-9-3">9.3. Clases genéricas</a></li>
<li><a href="#sec-9-4">9.4. Colecciones</a></li>
<li><a href="#sec-9-5">9.5. <code>List</code> y <code>BitArray</code></a></li>
<li><a href="#sec-9-6">9.6. <code>Stack</code> y <code>Queue</code></a></li>
<li><a href="#sec-9-7">9.7. <code>HashSet</code></a></li>
</ul>
</li>
</ul>
</div>
</nav>
</div><div class="col-md-9 col-md-pull-3"><h1 class="title">C#</h1>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Conceptos Básicos</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> C#</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Un elegante lenguaje orientado objetos.
</li>
<li>Corre sobre el .NET Framework.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> .NET Framework</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>Consiste en:
<ul class="org-ul">
<li><code>CLR (Common Languaje Runtime)</code>
<ul class="org-ul">
<li>Es la fundación de .NET.
</li>
<li>Maneja muchas cosas.
<ul class="org-ul">
<li>Código en tiempo de ejecución.
</li>
<li>Manejo de memoria.
</li>
<li>Etc.
</li>
</ul>
</li>
</ul>
</li>
<li><code>.NET Framework Class Library</code>.
<ul class="org-ul">
<li>Colección de clases, interfaces y Tipos de datos que te permiten hacer
Un rango de tareas de programación comunes.
</li>
<li>C# La Usa extensivamente.
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Variables</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>Reservan información en memoria.
</li>
<li>Deben tener nombres descriptivos.
</li>
<li>También son llamadas identificadores.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Tipos de variables</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>Define el tipo de valor que va a ser guardado en la variable asi como la memoria que se necesita.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int myAge;
</pre>
</div>


<blockquote>
<p>
Una linea de código que completa una acción es llamada declaración y terminan con punto y coma.
</p>
</blockquote>

<ul class="org-ul">
<li>Podemos asignarle un valor a la variable cuando la declaras.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int myAge = 18;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Tipos de datos</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>Hay algunos tipos de datos por defecto en C#.
<dl class="org-dl">
<dt> <code>int</code> </dt><dd>Entero.
</dd>
<dt> <code>float</code> </dt><dd>Números de coma flotante (Con decimales pues.).
</dd>
<dt> <code>double</code> </dt><dd>Una versión con más precisión (más dígitos) de float.
</dd>
<dt> <code>char</code> </dt><dd>Un carácter.
</dd>
<dt> <code>bool</code> </dt><dd><code>true</code> o <code>false</code>.
</dd>
<dt> <code>string</code> </dt><dd>Cadenas de caracteres.
</dd>
</dl>
</li>
</ul>

<blockquote>
<p>
valores <code>char</code> son definidos con comillas simples y <code>string</code> con comillas dobles.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Mi primer programa en C#</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>Cada aplicación de consola en C# debe tener una función llamada <code>Main</code>
<ul class="org-ul">
<li>Esta función es el punto de entrada para cada aplicación.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> Mostrando texto</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>La mayoría de las aplicaciones necesitan algún tipo de <code>input</code> y nos tan algún tipo de <code>output</code>.
</li>
<li>Para mostrar texto en pantalla usamos <code>Console.write()</code> o <code>Console.WriteLine()</code>.
<ul class="org-ul">
<li>La diferencia es que con el segundo al final del texto da un salto de linea.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">Console.WriteLine("Hola Mundo!");
</pre>
</div>

<ul class="org-ul">
<li>Para imprimir una cadena con un formato especifico podemos hacer.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int x = 10;
double y = 20;

Console.WriteLine("x = {0}; y = {1}", x, y);
</pre>
</div>

<blockquote>
<p>
<code>{0}</code> sera remplazado por el valor de <code>x</code> y <code>{1}</code> por el valor de <code>y</code>.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> Leyendo texto</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li>Podemos leer texto de la terminal con <code>Console.ReadLine()</code> y asignarlo a una variable.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">yourInput = Console.ReadLine();
</pre>
</div>

<blockquote>
<p>
Esto siempre retorna un <code>string</code>.
</p>
</blockquote>

<ul class="org-ul">
<li>Podemos Convertir este <code>string</code> en otro tipo de dato fácilmente con el método <code>Convert.ToXXX</code>.
<ul class="org-ul">
<li>EJ. <code>Convert.ToDouble</code> o <code>Convert.ToBoolean</code>.
<ul class="org-ul">
<li>También podemos convertir a enteros de un tamaño en especifico <code>Convert.ToInt16</code>, <code>Convert.ToInt32</code>, etc.
<ul class="org-ul">
<li>El tipo de dato por defecto en enteros es <code>Int32</code>.
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> Comentarios</h3>
<div class="outline-text-3" id="text-1-9">
<ul class="org-ul">
<li>Empiezan con <code>//</code>.
</li>
<li>Comentarios multilinea son <code>/* texto */</code>.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> La palabra <code>var</code></h3>
<div class="outline-text-3" id="text-1-10">
<ul class="org-ul">
<li>C# provee una forma de declarar variables y hacer que el compilador determine el tipo de dato de esta.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">var num = 15;
</pre>
</div>

<ul class="org-ul">
<li>Estas variables son llamadas de <b>Tipo implícito</b>.
</li>
<li>Estas variables <b>deben</b> ser inicializadas con un valor.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">// Esto dará un error!
var num;
num = 15;
</pre>
</div>

<blockquote>
<p>
Es buena práctica declarar tus variables con su tipo de dato y usar <code>var</code> solo para casos especiales.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> Constantes</h3>
<div class="outline-text-3" id="text-1-11">
<ul class="org-ul">
<li>Se definen constantes con la palabra <code>const</code>.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">//Ejemplo
const double PI = 3.14;
</pre>
</div>

<ul class="org-ul">
<li>Las constantes siempre deben se ser inicializadas asignandoles un valor.
</li>
<li>Son variables que no pueden ser cambiadas.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12"><span class="section-number-3">1.12</span> Operadores Aritméticos</h3>
<div class="outline-text-3" id="text-1-12">
<ul class="org-ul">
<li>Son los mismos de toda la vida <code>+, -, *, /, %</code>.
</li>
<li>Tienen una jerarquía de evaluación normal y esta puede afectarse con los parentesis.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13"><span class="section-number-3">1.13</span> Operadores de asignación e incremento</h3>
<div class="outline-text-3" id="text-1-13">
<pre class="example">
x += 2; // equivalente a x = x + 2;
x %= 2; // equivalente a x = x % 2;
// y de la misma manera con los operadores anteriores.
</pre>
</div>

<div id="outline-container-sec-1-13-1" class="outline-4">
<h4 id="sec-1-13-1"><span class="section-number-4">1.13.1</span> Operadores de incremento</h4>
<div class="outline-text-4" id="text-1-13-1">
<ul class="org-ul">
<li>Podemos incrementar un valor a una variable cada que nuestro programa pase por allí.
<ul class="org-ul">
<li>Es especialmente útil en ciclos.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">x++; // equivalente a x = x + 1;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-13-2" class="outline-4">
<h4 id="sec-1-13-2"><span class="section-number-4">1.13.2</span> Formas de prefijo y postfijo</h4>
<div class="outline-text-4" id="text-1-13-2">
<ul class="org-ul">
<li>El operador de incremento tiene dos formas.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">++x; // prefijo
x++; // postfijo
</pre>
</div>

<ul class="org-ul">
<li>Prefijo: Incrementa el valor y despues procede con la expresión.
</li>
<li>Postfijo: Evalúa la expresión y despues incrementa el valor.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int x = 3;
int y = ++x;
// x es 4, y es 4
</pre>
</div>

<div class="org-src-container">

<pre class="src src-csharp">int x = 3;
int y = x++;
// x es 4, y es 3
</pre>
</div>

<blockquote>
<p>
Esto también funciona con el operador de decremento <code>-</code>, siendo x&#x2013; y &#x2013;x.
</p>
</blockquote>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Condicionales y loops</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> <code>if else</code></h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>Ejecuta un bloque de código si una condición se cumple.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">if (x &gt; y)
    {
        Console.WriteLine("x es más grande que y");
    }
</pre>
</div>
</div>

<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> Operadores Relacionales</h4>
<div class="outline-text-4" id="text-2-1-1">
<ul class="org-ul">
<li>Se usan para evaluar condiciones.
</li>
<li>Son los mismos de siempre; !=, &gt;=, &lt;=, ==.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> Operador <code>else</code></h4>
<div class="outline-text-4" id="text-2-1-2">
<ul class="org-ul">
<li>Se ejecuta cuando no se cumple la condición dentro del <code>if</code>.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">if (x &gt; y)
    {
        Console.WriteLine("x es más grande que y");
    }
else
    {
        Console.WriteLine("y es más grande que x");
    }
</pre>
</div>

<ul class="org-ul">
<li>Podemos combinarlos y agruparlos como queramos
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">if ( x )
    {
        // algo
    }
else if ( y )
    {
        // otra cosa
    }
else if ( z )
    {
        //aaaaaa
    }
else
    {
        //final
    }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> operador <code>switch</code></h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>Provee una manera más elegante de comparar una variable con ciertos casos predefinidos.
</li>
<li>Cada caso es llamado <code>case</code>.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int num = 3;
switch (num)
    {
        case 1:
            Console.WriteLine("one");
            break;
        case 2:
            Console.WriteLine("two");
            break;
        case 3:
            Console.WriteLine("Three");
            break;
        default:
            Console.WriteLine("No es uno, dos o tres");
            break;
    }
</pre>
</div>

<blockquote>
<p>
Un <code>switch</code> puede incluir n número de casos, pero cada caso debe de ser único.
</p>
</blockquote>

<blockquote>
<p>
El bloque <code>default</code> solo se ejecuta si no se cumple ninguno de los <code>case</code>.
</p>
</blockquote>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> La palabra <code>break</code></h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>Se usa para romper el ciclo de ejecución del <code>switch</code>
<ul class="org-ul">
<li>Sin el, el <code>switch</code> seguirá comparando con otros case a pesar de entrar en uno.
</li>
<li>También sirve para romper ciclos <code>for</code> o <code>while</code>.
</li>
<li>En C# <code>break</code> es obligatorio al final de cada <code>case</code>.
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> El ciclo <code>while</code></h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>Ejecuta un bloque de código siempre y cuando una condición se cumpla.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int num = 1;
while (num &lt; 6)
    {
        Console.WriteLine(num);
        num++;
    }
</pre>
</div>

<blockquote>
<p>
El código anterior imprime los números del 1 al 5.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> El ciclo <code>for</code></h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>Ejecuta un bloque de código un número especifico de veces.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">for (init; condition; increment)
    {
        //code
    }
</pre>
</div>

<p>
<b>Ejemplo:</b>
</p>

<div class="org-src-container">

<pre class="src src-csharp">for (int x = 10; x &lt; 15; x++)
    {
        Console.WriteLine("Value of x: {0}", x);
    }
</pre>
</div>

<ul class="org-ul">
<li>En el bloque del incremento podemos hacer otras cosas como incrementar de 3 con <code>x+=3</code> o decrementar de la misma manera el contador.
</li>
<li>También podemos quitar el bloque <code>init</code> e <code>increment</code> del bloque, pero los puntos y comas son obligatorios.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int x = 10;
for ( ; x &gt; 10 ; )
    {
        Console.WriteLine(x);
        x -= 3;
    }
</pre>
</div>

<blockquote>
<p>
<code>for (;;){}</code> es un ciclo for infinito.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> <code>do-while</code></h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>Es similar a un ciclo <code>while</code>, solo que en este el bloque de código es ejecutado al menos una vez.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int a = 0;
do {
    Console.WriteLine(a);
    a++;
} while (a &lt; 5);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> <code>break</code> y <code>continue</code></h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>Otro uso de <code>break</code> es en ciclos, ya que &ldquo;rompe&rdquo; la ejecución de estos.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int num = 0;
while (num &lt; 20)
    {
        if (num == 5)
            break;

        Console.WriteLine(num);
        num++;
    }
</pre>
</div>

<blockquote>
<p>
En el bloque de anterior, el <code>while</code> parará cuando <code>num</code> sea igual a 5.
</p>
</blockquote>

<ul class="org-ul">
<li>La palabra <code>continue</code> es similar al <code>break</code>, pero este solo se salta una iteración del ciclo.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">for (int i = 0; i &lt; 10; i++) {
    if (i == 5)
        continue;

    Console.WriteLine(i);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> Operadores lógicos</h3>
<div class="outline-text-3" id="text-2-7">
<ul class="org-ul">
<li>Son usados para unir múltiples expresiones y retornar <code>true</code> o <code>false</code>.
</li>
<li>son <code>&amp;&amp;, ||, !</code>, AND, OR y NOT respectivamente.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int age = 42;
doubel money = 540;
if (age &gt; 18 &amp;&amp; money &gt; 100) {
    Console.WriteLine("Welkome");
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8"><span class="section-number-3">2.8</span> El operador condicional</h3>
<div class="outline-text-3" id="text-2-8">
<ul class="org-ul">
<li>También llamado operador ternario.
</li>
<li>Podemos hacer una operación condicional asi como en el if pero con una sola línea de código.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">Expr1 ? Expr2 : Expr3;
</pre>
</div>

<ul class="org-ul">
<li>La Expr1, es evaluada, si esta es verdadera.
<ul class="org-ul">
<li>Entonces Exp2 es evaluada y se convierte en el valor de toda la expresión.
</li>
</ul>
</li>
<li>Si Expr1 es falsa, entonces Exp3 es evaluada y se convierte en el valor de toda la expresión.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int age = 42;
string msg;
msg = (age &gt;= 18) ? "Welcome" : "Sorry";
Console.WriteLine(msg)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Métodos</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Introducción a los métodos</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>Un método es un grupo de declaraciones que hacen una tarea en particular.
</li>
<li>Además de los métodos que tiene C# puedes definir los tuyos.
</li>
<li>Tienen muchas ventajas:
<ul class="org-ul">
<li>Son código reusable.
</li>
<li>Fáciles de testear.
</li>
<li>Modificaciones a un método no afectan al programa.
</li>
<li>Un método puede aceptar diferentes tipos de inputs.
</li>
</ul>
</li>
</ul>

<blockquote>
<p>
Todo programa de C# tiene al menos un método, el método <code>Main</code>.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Declarando métodos</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>Para usar un método primero necesitas declararlo, y después llamarlo.
</li>
<li>Cada declaración de método incluye:
<ul class="org-ul">
<li>El tipo de dato que retorna.
</li>
<li>El nombre del método.
</li>
<li>Una lista opcional de parametros.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">&lt;tipo de dato de retorno&gt; name(type1 part1, type2 part2, ..., typeN partN){
    //Bloque de código..
    return &lt;tipo de dato&gt;
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-csharp">int Sqr(int x)
    {
        int result = x * x;
        return result;
    }
</pre>
</div>

<ul class="org-ul">
<li>Podemos hacer que métodos no retornen nada poniendoles el tipo de dato <code>void</code>.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Llamando a métodos</h3>
<div class="outline-text-3" id="text-3-3">
<div class="org-src-container">

<pre class="src src-csharp">static void SayHi()
    {
        Console.WriteLine("Hello");
    }

static void Main(string[] args)
    {
        SayHi();
    }
</pre>
</div>

<blockquote>
<p>
Aquí declaramos un método y lo llamamos desde <code>Main</code>, la palabra <code>static</code> es para hacer los métodos accesibles al <code>Main</code>.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Parametros</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>Las declaraciones de métodos pueden definir una serie de parametros para trabajar.
</li>
<li>Estos parametros son variables que aceptan valores específicos.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">void Print(int x)
    {
        Console.WriteLine(x);
    }
</pre>
</div>

<blockquote>
<p>
Las declaraciones de parametros son similares a las declaraciones de variables; Estas solo existen dentro del método donde se declararon.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-csharp">void Print(int x)
    {
        Console.WriteLine(x);
    }

static void Main(string[] args)
    {
        Print(42);
    }
</pre>
</div>

<blockquote>
<p>
Ahora podemos llamar a nuestro método y pasarle argumentos.
</p>
</blockquote>
</div>

<div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1"><span class="section-number-4">3.4.1</span> Parametros múltiples</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>Se pueden tener N número de parametros en un método separandolos con comas en la definición.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int Sum(int x, int y)
    {
        return x + y;
    }
</pre>
</div>

<blockquote>
<p>
Los métodos retornan valores con la palabra <code>return</code>.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-csharp">int Sum(int x, int y)
    {
        return x + y;
    }

static void Main(string[] args)
    {
        suma = Sum(42, 45);
        Console.WriteLine(suma);
    }
</pre>
</div>

<blockquote>
<p>
Podemos asignar parametros múltiples cuando llamamos al método, separandolos con comas, asi como también guardar lo que nos regresa el método en una variable para usarlo después.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2"><span class="section-number-4">3.4.2</span> Parametros opcionales</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>Cuando defines métodos puedes declarar valores por defecto a parametros opcionales.
</li>
<li>Si estos parametros no están presentes cuando se llama al método se usan los valores por defecto.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">static int Pow(int x, int y=2)
    {
    int result = 1;
    for (int i = 0; i &lt; y; i++)
        {
            result *= x;
        }

    return result;
    }
</pre>
</div>

<blockquote>
<p>
El método <code>Pow</code> asigna un valor por defecto de 2 al parametro y.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-csharp">static void Main(string[] args)
    {
        Console.WriteLine(Pow(4));
        Console.WriteLine(Pow(4,3));
    }
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-4-3" class="outline-4">
<h4 id="sec-3-4-3"><span class="section-number-4">3.4.3</span> Parametros nombrados</h4>
<div class="outline-text-4" id="text-3-4-3">
<ul class="org-ul">
<li>Los argumentos nombrados nos ayudan a no tener que recordar el orden de los parametros.
</li>
<li>Cada argumento puede ser especificado a la variable a la que pertenece.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">static int Are(int h, int w)
    {
        return h * w;
    }

static void Main(string[] args)
    {
        int res = Area(w: 5, h: 8);
        Console.WriteLine(res);
    }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Pasando argumentos</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>Hay tres maneras de pasar argumentos a un método cuando este es llamado.
<ul class="org-ul">
<li>Por valor, por referencia y como <i>Output</i>.
</li>
<li>Si se hace por valor, copia el argumento del valor dentro del parámetro formal del método.
<ul class="org-ul">
<li>Este es el comportamiento por defecto de C#.
</li>
</ul>
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">static void Sqrt(int x)
    {
        x = x * x;
    }
static void Main()
    {
        int a = 3;
        Sqrt(a);
        Console.WriteLine(a); // imprime 3
    }
</pre>
</div>

<ul class="org-ul">
<li>En este caso <code>x</code> es parametro de <code>Sqrt</code>, y a es el valor pasado al método.
</li>
</ul>

<blockquote>
<p>
El método <code>Sqrt()</code> no cambia el valor de la variable, trabaja con el valor, no con la variable.
</p>
</blockquote>
</div>

<div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1"><span class="section-number-4">3.5.1</span> Pasando por referencia</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>Pasar un argumento por referencia, copia la dirección de memoria en el parametro formal del método.
<ul class="org-ul">
<li>Dentro de este, esta dirección es usada para acceder al argumento.
<ul class="org-ul">
<li>Esto significa que los cambios que se hacen dentro del método, afectan al parametro.
</li>
</ul>
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">static void Sqrt(ref int x) // &lt;---
    {
        x = x * x;
    }
static void Main()
    {
        int a = 3;
        Sqrt(ref a); // &lt;---
        Console.WriteLine(a); // imprime 9
    }
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-5-2" class="outline-4">
<h4 id="sec-3-5-2"><span class="section-number-4">3.5.2</span> Pasando por Output</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>Parecidos a pasar por referencia.
<ul class="org-ul">
<li>La diferencia esta en que estos transfieren datos fuera del método (como un return).
</li>
</ul>
</li>
<li>Son útiles para retornar varios valores de un método.
</li>
<li>Son denotados por la palabra <code>out</code>.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">static void GetValues(out int x, out int y) // &lt;---
    {
        x = 5;
        y = 10;
    }
static void Main()
    {
        int a, b;
        GetValues(out a, out b);
        // Ahora a = 5 y b = 10
    }
</pre>
</div>

<blockquote>
<p>
Las variables deben de estar inicializadas, pero no tener ningún valor.
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> Sobrecarga</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>La Sobrecarga de métodos es cuando dos métodos tienen el mismo nombre pero diferentes parametros.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">void Print(int a)
    {
        Console.WriteLine("Value: " + a);
    }
void Print(double a)
    {
        Console.WriteLine("Value: " + a);
    }
</pre>
</div>

<blockquote>
<p>
Con la sobrecarga podemos tener una misma función que funcione con <code>int</code> y con <code>double</code>.
</p>
</blockquote>

<ul class="org-ul">
<li>Cuando se hace sobrecarga, la definición de los métodos debe diferir en su tipo o numero de argumentos.
<ul class="org-ul">
<li>Cuando se llame, esta llamada llegara a la implementación que coincida con lo que se da.
</li>
</ul>
</li>
<li>Todos los métodos deben coincidir en el tipo de retorno que tienen.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> Recursividad</h3>
<div class="outline-text-3" id="text-3-7">
<ul class="org-ul">
<li>Es un método que se llama a si mismo.
</li>
<li>Un ejemplo puede ser el calculo del factorial de un número.
<ul class="org-ul">
<li>num * num-1 hasta 1.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">static int Fact(int num)
    {
        if (num == 1) {
            return 1;
        }
        return num * Fact(num-1);
    }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Clases y objetos</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Clases</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>En la programación orientada a objetos una clase es un tipo de dato que define un conjunto de:
<ul class="org-ul">
<li>Variables y métodos para un objeto declarado.
</li>
</ul>
</li>
<li>Una clase es como un plano.
<ul class="org-ul">
<li>Define datos y comportamientos para un tipo.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class MiPrimeraClase
    {
        //variables, métodos, etc.
    }
</pre>
</div>

<blockquote>
<p>
Define un tipo de dato para objetos, pero no es un objeto.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Objetos</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>Una clase puede usarse para declarar múltiples objetos.
</li>
<li>Un objeto es llamado también es llamado una instancia de una clase.
</li>
<li>Cada objeto tiene sus propias características, llamadas atributos.
<ul class="org-ul">
<li>Las cuales son heredadas de la clase de la cual es instancia.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Valor y tipos de referencia</h3>
<div class="outline-text-3" id="text-4-3">
</div><div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1"><span class="section-number-4">4.3.1</span> Tipos de Valor</h4>
<div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li>C# tiene dos formas de guardar valores, por referencia y por valor.
</li>
<li>Los tipos de dato predeterminados son usados para declarar variables que son tipos de valor.
<ul class="org-ul">
<li>Su valor es guardado en la memoria en un lugar llamado <i>stack</i> (la pila).
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-2" class="outline-4">
<h4 id="sec-4-3-2"><span class="section-number-4">4.3.2</span> Tipos de referencia.</h4>
<div class="outline-text-4" id="text-4-3-2">
<ul class="org-ul">
<li>El tipo de referencia es usado para guardar objetos.
<ul class="org-ul">
<li>Como por ejemplo cuando instancias un objeto es guardado como un tipo de referencia.
</li>
</ul>
</li>
<li>Estos son guardados en una parte de la memoria llamada <i>heap</i> (Montículo).
<ul class="org-ul">
<li>Cuando instancias un objeto, los datos de este son guardados en la <i>heap</i> mientras que la dirección de memoria de la heap es guardada en el <i>stack</i>.
</li>
</ul>
</li>
</ul>


<figure>
<p><img src="./images/SS-01.png" class="img" align="center">
</p>
</figure>

<dl class="org-dl">
<dt> <code>Stack</code> </dt><dd>Es usado para asignación de memoria estática, eso incluye a todas tus variables como x.
</dd>
<dt> <code>Heap</code> </dt><dd>Es usada para asignación de memoria dinámica, eso incluye objetos <i>custom</i> que podrían necesitar más memoria durante la ejecución de un programa.
</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> Clases</h3>
<div class="outline-text-3" id="text-4-4">
<div class="org-src-container">

<pre class="src src-csharp">class Person
    {
        int age;
        string name;
        public void SayHi()
            {
                Console.WriteLine("Hola");
            }
    }
</pre>
</div>

<ul class="org-ul">
<li>En el código de arriba tenemos una clase Persona.
<ul class="org-ul">
<li>Tiene las variables <code>age</code> y <code>name</code>, asi como el método <code>SayHi</code>.
</li>
</ul>
</li>
<li>Podemos incluir <code>access modifiers</code> (modificadores de acceso), también llamados <code>members</code> (miembros).
<ul class="org-ul">
<li>Son palabras claves usadas para especificar la accesibilidad a un miembro.
</li>
<li>Un miembro definido como público puede se accedido desde afuera de la clase.
<ul class="org-ul">
<li>Por eso es que <code>SayHi()</code> es público.
</li>
</ul>
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Person {
    int age;
    string name;
    public void SayHi() {
        Console.WriteLine("Hi");
    }
}
static void Main(string[] args)
{
    Person p1 = new Person();
    p1.SayHi();
}
</pre>
</div>


<ul class="org-ul">
<li>El operador <code>new</code>, instancia al objeto y retorna una referencia de este a su posición en la heap.
</li>
<li>El código de arriba instancia un objeto tipo <code>Person</code> llamado <code>p1</code> y lo usa para llamar al método público <code>SayHi()</code>.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Dog
{
    public string name;
    public int age;
}
static void Main(string[] args)
{
    Dog bob = new Dog();
    bob.name = "Bobby";
    bob.age = 3;

    Console.WriteLine(bob.age);
}
</pre>
</div>

<ul class="org-ul">
<li>Podemos acceder a los miembros públicos de una clase, en el ejemplo las variables nombre y edad.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> Encapsulación</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li>En programación se refiere a restringir el acceso a ciertas partes de una clase.
<ul class="org-ul">
<li>Es llamado también <code>information hiding</code>.
</li>
<li>Nos permite ocultar detalles de una clase.
</li>
</ul>
</li>
<li>C# nos da las siguientes modificadores de acceso:
<ul class="org-ul">
<li><code>public</code>.
<ul class="org-ul">
<li>Hace un miembro accesible desde fuera de la clase.
</li>
</ul>
</li>
<li><code>private</code>.
<ul class="org-ul">
<li>Hace los miembros accesibles solo dentro de la clase y los oculta fuera de esta.
</li>
</ul>
</li>
<li><code>protected</code>.
</li>
<li><code>internal</code>.
</li>
<li><code>protected internal</code>.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class BankAccount {
    private double balance=0;
    public void Deposit(double n) {
        balance += n;
    }
    public void Withdraw(double n) {
        balance -= n;
    }
    public double GetBalance() {
        return balance;
    }
}
class Program
{
    static void Main(string[] args)
    {
        BankAccount b = new BankAccount();
        b.Deposit(199);
        b.Withdraw(42);
        Console.WriteLine(b.GetBalance());
    }
}
</pre>
</div>

<ul class="org-ul">
<li>Usamos encapsulación para ocultar la variable <code>balance</code>.
</li>
<li>Aun así podemos acceder a <code>balance</code> mediante los métodos <code>Deposit()</code>, <code>Withdraw()</code> y <code>GetBalance()</code>.
<ul class="org-ul">
<li>Así podemos tener el control sobre lo que pasa con la variable <code>balance</code> y aplicar distintas verificaciones sobre lo que queremos hacer.
</li>
</ul>
</li>
<li>La encapsulación nos permite:
<ul class="org-ul">
<li>Controlar la manera en la que se accede a los datos o en la que se modifican.
</li>
<li>Podemos extender el código de una manera más segura y limpia a nuevos requerimientos.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> Constructores</h3>
<div class="outline-text-3" id="text-4-6">
<ul class="org-ul">
<li>Es un miembro especial de una clase que se ejecuta cuando se crea un nuevo objeto de esta clase.
</li>
<li>Tienen el mismo nombre que la clase, son públicos y no tienen ningún retorno.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Person
{
  private int age;
  public Person()
  {
    Console.WriteLine("Hi there");
  }
}
</pre>
</div>

<ul class="org-ul">
<li>Esto es útil cuando necesitamos que el objeto sea creado con ciertos parametros.
<ul class="org-ul">
<li>Por default no tienen parametros, pero si se necesitan pueden agregarse.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Person
{
    private int age;
    private string name;
    public Person(string nm)
    {
        name = nm;
    }
    public string getName()
    {
        return name;
    }
}
static void Main(string[] args)
{
    Person p = new Person("David");
    Console.WriteLine(p.getName());
}
</pre>
</div>

<blockquote>
<p>
En el ejemplo creamos un objeto pasándole un argumento al constructor.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> Propiedades</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li>Es una buena práctica encapsular los miembros de una clase y proveer acceso a ellos solo cuando es necesario.
</li>
<li>Una propiedad es un miembro que provee un mecanismo flexible para leer, escribir o computar el valor de un campo privado.
<ul class="org-ul">
<li>Estas pueden ser usadas como miembros públicos pero incluyen métodos llamados <code>accessors</code>.
<ul class="org-ul">
<li>Estos incluyen declaraciones que podemos usar para obtener <i>get</i> (leer o computar) o <i>set</i> (escribir) un campo en especifico.
</li>
</ul>
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Person {
    private string name; //campo

    public string Name // Propiedad
        {
            get { return name; }
            set { name = value; }
        }
}
</pre>
</div>

<ul class="org-ul">
<li>En el ejemplo, la clase <code>Person</code> tiene una propiedad llamada <code>Name</code> que tiene un <code>set</code> y un <code>get</code> para acceder a el campo <code>name</code>.
</li>
</ul>

<blockquote>
<p>
<code>value</code> representa el valor que le asignemos a una propiedad usando <code>set</code>.
</p>
</blockquote>

<blockquote>
<p>
Se le puede llamar a una propiedad con cualquier nombre pero la convención es que las propiedades tengan el mismo nombre que el campo peo con mayúscula en la primera letra.
</p>
</blockquote>

<p>
Una vez la propiedad es definida podemos usarla para asignar o leer del miembro.
</p>

<div class="org-src-container">

<pre class="src src-csharp">static void Main(string[] args)
    {
        Person p = new Person;
        p.Name = "Bob";
        Console.WriteLine(p.Name);
    }
</pre>
</div>

<blockquote>
<p>
Se accede a la propiedad por su nombre, como cualquier miembro público de la clase.
</p>
</blockquote>

<ul class="org-ul">
<li>Podemos tener una propiedad con solo un <code>get</code> y sin un <code>set</code> o hacer la propiedad privada.
</li>
<li>Las propiedades nos permiten tener la opción de controlar la lógica de acceder a una variable.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Person {
    private int age=0;
    public int Age;
    {
        get { return age; }
        set {
            if (value &gt; 0) {
                age = value;
            }
        }
    }
}
</pre>
</div>

<blockquote>
<p>
En el ejemplo verificamos que el valor que le asignemos a <code>age</code> sea mayor a 0.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8"><span class="section-number-3">4.8</span> Propiedades auto implementadas.</h3>
<div class="outline-text-3" id="text-4-8">
<ul class="org-ul">
<li>Cuando no necesitas ninguna lógica las propiedades, C# provee una manera rápida para declarar miembros privados a través de sus propiedades.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">public string Name { get; set; }
</pre>
</div>

<ul class="org-ul">
<li>Esta es la llamada propiedad auto-implementada.
</li>
<li>Usándola ya no necesitamos declarar el campo privado por separado.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Person {
    public string Name { get; set; }
}
static void Main(string[] args)
    {
        Person p = new Person;
        p.Name = "Bob";
        Console.WriteLine(p.Name);
    }
// Imprime Bob
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Arreglos y Cadenas</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Arreglos</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>También llamados <i>Arrays</i>.
</li>
<li>C# provee numerosas clases para guardar y manipular datos.
</li>
<li>Es una colección de elementos del <b>mismo tipo</b>.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">// declaración de un array
int [ ] myArray;
</pre>
</div>

<blockquote>
<p>
Con esto declaramos un arreglo de enteros.
</p>
</blockquote>

<ul class="org-ul">
<li>Pero sabiendo que los arreglos son objetos, debemos declararlos como tal.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int [ ] myArray = new int[5];
</pre>
</div>

<blockquote>
<p>
Con esto instanciamos un arreglo de enteros con 5 espacios dentro de el.
</p>
</blockquote>

<ul class="org-ul">
<li>Despues de crear un arreglo podemos asignar valores en un índice especifico.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int [ ] myArray = new int[5];
myArray[0] = 23
</pre>
</div>

<blockquote>
<p>
Aquí asignamos el número 23 en la posición 0 del arreglo.
</p>
</blockquote>

<ul class="org-ul">
<li>En C# los arreglos empiezan en 0.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">string [ ] names = new string[3] {"Jhon", "Cena", "Jose"};
</pre>
</div>

<blockquote>
<p>
Podemos asignar valores iniciales a un arreglo se esta forma.
</p>
</blockquote>

<ul class="org-ul">
<li>Si asignamos valores iniciales podemos omitir el número de elementos que son en la declaración.
</li>
<li>Incluso podemos omitir el operador new.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">string [ ] names = {"Jhon", "Cena", "Jose"};
</pre>
</div>

<ul class="org-ul">
<li>Para acceder a los elementos del arreglo solo tenemos que especificar el número de índice que tiene el elemento.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">Console.WriteLine(names[2]);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Usando arreglos en ciclos</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>A veces es necesario iterar sobre los elementos de un arreglo.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int[ ] a = new int[10];

for (int k = 0; k &lt; 10; k++) {
  a[k] = k*2;
}
</pre>
</div>

<ul class="org-ul">
<li>Esto se puede lograr de manera fácil y rápida con un ciclo <code>for</code>.
</li>
</ul>
<div class="org-src-container">

<pre class="src src-csharp">for (int k = 0; k &lt; 10; k++) {
    Console.WriteLine(a[k]);
}
</pre>
</div>
</div>

<div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1"><span class="section-number-4">5.2.1</span> El ciclo <code>foreach</code></h4>
<div class="outline-text-4" id="text-5-2-1">
<ul class="org-ul">
<li>El ciclo <code>foreach</code> nos da una manera más fácil de acceder a los elementos de un arreglo.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">foreach (int k in a) {
    Console.WriteLine(k);
}
</pre>
</div>

<blockquote>
<p>
Este es el equivalente de el ejemplo anterior con un ciclo <code>for</code>.
</p>
</blockquote>

<ul class="org-ul">
<li>Este itera sobre el arreglo, y asigna el valor del elemento actual a <code>k</code>.
</li>
</ul>

<blockquote>
<p>
El tipo de dato dentro del <code>foreach</code> debe de coincidir con el tipo de los elementos del arreglo.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-csharp">// a veces se usa la parlabra var dentro del foreach
foreach (var k in a) {
    //aaaaaa
}
</pre>
</div>

<ul class="org-ul">
<li>Esto se hace para que el compilador determine el tipo de dato apropiado automáticamente.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Arreglos multidimencionales</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>Los arreglos pueden tener mútltipes dimensiones.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int [ , ] x = new int[3,4];
</pre>
</div>

<blockquote>
<p>
Esto es una matriz de 3x4.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> Arreglos dentados</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li>También llamados <i>jagged arrays</i>.
</li>
<li>Es básicamente un arreglo en el cual sus elementos son arreglos.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int [][] = jaggedArr = new int[3][];
</pre>
</div>

<blockquote>
<p>
Tenemos un arreglo de una sola dimensión, con 3 elementos, los cuales son arreglos de una sola dimensión.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-csharp">int[ ][ ] jaggedArr = new int[ ][ ]
{
  new int[ ] {1,8,2,7,9},
  new int[ ] {2,4,6},
  new int[ ] {33,42}
};
</pre>
</div>

<blockquote>
<p>
Si queremos tener valores iniciales, podemos declarar el mismo arreglo de esta manera.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-csharp">int x = jaggedArr[2][1]; //42
</pre>
</div>

<blockquote>
<p>
Podemos acceder a los elementos del arreglo de esta manera.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> Propiedades de los arreglos y métodos</h3>
<div class="outline-text-3" id="text-5-5">
</div><div id="outline-container-sec-5-5-1" class="outline-4">
<h4 id="sec-5-5-1"><span class="section-number-4">5.5.1</span> Propiedades de los arreglos</h4>
<div class="outline-text-4" id="text-5-5-1">
<ul class="org-ul">
<li>La clase de <code>array</code> nos da distintas propiedades y métodos para trabajar con ella.
<ul class="org-ul">
<li>Por ejemplo las propiedades <code>Length</code> y <code>Rank</code> nos dejan saber la longitud y las dimensiones de un arreglo respectivamente.
</li>
<li>Algunos métodos que nos da la clase <code>array</code> son: <code>Max</code>, <code>Min</code>, <code>Sum</code> que nos retornan el elemento máximo, mínimo y la suma de todos los elementos
respectivamente.
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> Trabajando con cadenas</h3>
<div class="outline-text-3" id="text-5-6">
</div><div id="outline-container-sec-5-6-1" class="outline-4">
<h4 id="sec-5-6-1"><span class="section-number-4">5.6.1</span> Cadenas</h4>
<div class="outline-text-4" id="text-5-6-1">
<ul class="org-ul">
<li>Es común pensar en las cadenas de caracteres como un arreglo de caracteres, pero en C# son objetos.
</li>
<li>Cuando creas una cadena en C#, instancias un objeto de la clase <code>string</code>.
</li>
<li>Tenemos unas cuantas propiedades y métodos útiles para trabajar con cadenas.
<ul class="org-ul">
<li><code>Length</code>: Nos retorna la longitud de una cadena.
</li>
<li><code>IndexOf(value)</code>: Retorna el índice del la primera ocurrencia al valor dado.
</li>
<li><code>Insert(index, value)</code>: Inserta el valor dado en la posición dada.
</li>
<li><code>Remove(index)</code>: Remueve todos los caracteres de la cadena desde el índice especificado.
</li>
<li><code>Substring(index, lenth)</code>: Retorna una porción de la cadena, con desde el índice y por la longitud dada.
</li>
<li><code>Contains(value)</code>: Retorna <code>True</code> si la cadena contiene el valor especificado.
</li>
</ul>
</li>
<li>También podemos acceder a los elementos de una cadena por su índice, como si fuera un arreglo.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">static void Main(string[] args)
        {
            string text = "This is some text about a dog. The word dog appears in this text a number of times. This is the end.";
            text = text.Replace("dog", "cat");
            text = text.Substring(0, text.IndexOf(".")+1);

            Console.WriteLine(text);
        }
</pre>
</div>

<blockquote>
<p>
C# tiene muchos métodos para trabajar con cadenas.
</p>
</blockquote>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Más sobre clases</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Destructores</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>Así como los constructores son usados cuando una clase es instanciada los destructores son usados cuando una clase es destruida o borrada.
</li>
<li>Los destructores tienes las siguientes características:
<ul class="org-ul">
<li>Una clase solo puede tener un solo destructor.
</li>
<li>Los destructores no pueden ser llamados, son llamados automáticamente.
</li>
<li>No toman parametros o modificadores.
</li>
<li>El nombre de el destructor tiene que ser el mismo que el de la clase con un <code>~</code> antes del nombre.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Dog {
    ~Dog()
        {
            //Código
        }
}
</pre>
</div>

<blockquote>
<p>
Son útiles para liberar recursos cuando sales del programa, ejemplos pueden ser: cerrando archivos, liberar memoria, etc.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-csharp">class Dog
{
    public Dog() {
        Console.WriteLine("Constructor");
    }
    ~Dog() {
        Console.WriteLine("Destructor");
    }
}
static void Main(string[] args)
{
    Dog d = new Dog();
}
</pre>
</div>

<blockquote>
<p>
En este ejemplo, cuando instanciamos el objeto el programa imprime &ldquo;Constructor&rdquo; y cuando el programa termina,
el objeto es borrado y el destructor imprime &ldquo;Destructor&rdquo;.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Miembros estáticos</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>Todos los miembros de una clase (variables, propiedades, métodos) pueden ser declarados como <code>static</code> (estáticos).
<ul class="org-ul">
<li>Esto hace que los miembros pertenezcan a la clase en vez de pertenecer al objeto individual.
<ul class="org-ul">
<li>No importa cuantos objetos de la clase son creados, solo hay una copia del miembro estático.
</li>
</ul>
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Cat {
    public static int count=0;
    public Cat() {
        count++;
    }
}
</pre>
</div>

<blockquote>
<p>
No importa cuantos objetos <code>Cat</code> instanciemos, <code>count</code> siempre sera el mismo para todos estos.
</p>
</blockquote>

<ul class="org-ul">
<li>Debido a su naturaleza global, estos miembros pueden ser accedidos directamente usando el nombre de la clase.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Cat {
    public static int count=0;
    public Cat() {
        count++;
    }
}
static void Main(string[] args)
    {
        Cat c1 = new Cat();
        Cat c2 = new Cat();

        Console.WriteLine(Cat.count()); // 2
    }
</pre>
</div>

<blockquote>
<p>
En el ejemplo accedemos a la variable <code>count</code> con el nombre de la clase y no el de las instancias, y esta variable es la misma en todas las instancias de <code>Cat</code>.
</p>
</blockquote>

<blockquote>
<p>
Se debe acceder a los miembros estáticos con el nombre de la clase siempre.
</p>
</blockquote>

<p>
<b>El mismo concepto se aplica a los métodos estáticos.</b>
</p>

<div class="org-src-container">

<pre class="src src-csharp">class Dog {
    public static void Bark() {
        Console.WriteLine("Woof");
    }
}
static void Main(string[] args)
    {
        Dog.Bark();
    }
</pre>
</div>

<blockquote>
<p>
Métodos estáticos solo pueden acceder a miembros estáticos.
</p>
</blockquote>

<blockquote>
<p>
El método <code>Main</code> es estático, y es el punto de entrada de cualquier programa, entonces cualquier método llamado directamente desde el Main tiene que ser estático.
</p>
</blockquote>

<ul class="org-ul">
<li>Las constantes son estáticas por definición.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Math {
    public const int ONE = 1;
}
</pre>
</div>
</div>

<div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1"><span class="section-number-4">6.2.1</span> Constructores estáticos</h4>
<div class="outline-text-4" id="text-6-2-1">
<ul class="org-ul">
<li>Los constructores pueden ser declarados estáticos para inicializar miembros estáticos de la clase.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class SomeClass {
    public static int x { get; set; }
    public static int y { get; set; }

    static SomeClass() {
        x = 10;
        y = 10;
    }
}
</pre>
</div>

<blockquote>
<p>
El constructor sera llamado cuando intentemos acceder a <code>SomeClass.X</code> o <code>SomeClass.Y</code>.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-6-2-2" class="outline-4">
<h4 id="sec-6-2-2"><span class="section-number-4">6.2.2</span> Clases estáticas</h4>
<div class="outline-text-4" id="text-6-2-2">
<ul class="org-ul">
<li>Una clase puede ser declarada como estática.
<ul class="org-ul">
<li>Solo puede contener miembros estáticos.
</li>
</ul>
</li>
<li>No se puede instanciar un objeto de una clase estática, ya que solo una instancia puede existir en el programa.
</li>
<li>Son útiles para combinar propiedades lógicas y métodos.
<ul class="org-ul">
<li>La clase <code>Math</code> es un buen ejemplo.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">Console.WriteLine(Math.Pow(2, 3));
</pre>
</div>

<blockquote>
<p>
Podemos acceder a la clase <code>Math</code> usando el nombre de la clase, sin declarar un objeto
</p>
</blockquote>
</div>

<ol class="org-ol"><li><a id="sec-6-2-2-1" name="sec-6-2-2-1"></a>Ejemplos<br ><div class="outline-text-5" id="text-6-2-2-1">
<p>
La clase <code>Array</code> tiene algunos métodos estáticos para manipular arrelgos.
</p>

<div class="org-src-container">

<pre class="src src-csharp">int[] arr = {1, 2, 3, 4};

Array.Reverse(arr);
//arr = {4, 3, 2, 1}

Array.Sort(arr);
//arr = {1, 2, 3, 4}
</pre>
</div>

<p>
La clase <code>String</code> también los tiene.
</p>

<div class="org-src-container">

<pre class="src src-csharp">string s1 = "some text";
string s2 = "another text";

String.Concat(s1, s2); // combines the two strings

String.Equals(s1, s2); // returns false
</pre>
</div>

<blockquote>
<p>
La clase <code>Console</code> También es otro ejemplo de una clase estática.
</p>
</blockquote>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> <code>This</code> &amp; <code>readonly</code></h3>
<div class="outline-text-3" id="text-6-3">
</div><div id="outline-container-sec-6-3-1" class="outline-4">
<h4 id="sec-6-3-1"><span class="section-number-4">6.3.1</span> <code>This</code></h4>
<div class="outline-text-4" id="text-6-3-1">
<ul class="org-ul">
<li>La palabra <code>This</code> es usada dentro de una clase y se refiere a la instancia actual de la clase.
<ul class="org-ul">
<li>Al objeto actual.
</li>
</ul>
</li>
<li>Se usa comúnmente para distinguir los miembros de la clase de otros datos como.
<ul class="org-ul">
<li>Parametros locales o formales de un método.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Person {
    private string name;
    public Person(string name) {
        this.name = name;
    }
}
</pre>
</div>

<blockquote>
<p>
Aquí, <code>this.name</code> representa el miembro de la clase y <code>name</code> el nombre el parametro del constructor.
</p>
</blockquote>

<blockquote>
<p>
Otro uso común de <code>this</code> es para pasar la instancia actual a un método como un parametro: <code>ShowPersonInfo(this);</code>
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-6-3-2" class="outline-4">
<h4 id="sec-6-3-2"><span class="section-number-4">6.3.2</span> El modificador <code>readonly</code></h4>
<div class="outline-text-4" id="text-6-3-2">
<ul class="org-ul">
<li>Previene que un miembro de una clase sea modificado despues de la construcción.
<ul class="org-ul">
<li>Esto significa que solo puede ser modificado cuando lo declaras desde un constructor.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Person {
    private readonly string name = "John";
    public Person(string name) {
        this.name = name;
    }
}
</pre>
</div>

<blockquote>
<p>
Si intentamos modificar el campo <code>name</code> en algún otro lugar tendremos un error.
</p>
</blockquote>

<ul class="org-ul">
<li><code>readonly</code> y <code>const</code> son parecidos pero tienen ciertas diferencias.
<ul class="org-ul">
<li>Una campo <code>const</code> debe de ser inicializado con un valor y <code>readonly</code> no.
</li>
<li>Un campo <code>readonly</code> puede ser cambiado en un constructor, el <code>const</code> no.
</li>
<li>Un campo <code>readonly</code> puede ser asignado a un valor que es el resultado de un calculo, <code>const</code> no.
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> Indexadores</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>Permiten a objetos ser indexados como si fueran un arreglo.
</li>
<li>Un ejemplo es la clase <code>String</code>, la cual es un arreglo de objetos tipo <code>Char</code> implementando un indexadores para que podamos acceder a los elementos.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">string str = "Hello World";
char x = str[4];
Console.WriteLine(x);
</pre>
</div>

<ul class="org-ul">
<li>La declaración de un indexador es similar a una propiedad.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Clients {
    private string[] names = new string[10];

    public string this[int index] {
        get {
            return names[index];
        }
        set {
            names[index] = value;
        }
    }
}
</pre>
</div>

<ul class="org-ul">
<li>Todos los indexadores necesitan un índice.
</li>
<li>Se usan <code>get</code> y <code>set</code> para definir un indexador.
<ul class="org-ul">
<li>La diferencia es que los indexadores retornan o ponen un valor particular de la instancia del objeto.
</li>
</ul>
</li>
<li>Son definidos con la palabra <code>this</code>.
<ul class="org-ul">
<li>Esto para obtener o poner el elemento de la instancia.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">Clients c = new Clients();
c[0] = "Dave";
c[1] = "Bob";

Console.WriteLine(c[1]);
</pre>
</div>

<blockquote>
<p>
Se usan indexadores típicamente si la clase representa una lista, colección o un arreglo de objetos.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> Sobrecarga de Operadores</h3>
<div class="outline-text-3" id="text-6-5">
<ul class="org-ul">
<li>La mayoría de los operadores en C# puede ser sobrecargados.
<ul class="org-ul">
<li>Esto significa que pueden ser redefinidos para que hagan otras cosas.
</li>
</ul>
</li>
<li>Por ejemplo, podemos redefinir el comportamiento de <code>+</code> en una clase.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Box {
    public int Height {get; set;}
    public int Width {get; set;}
    public Box(int h, int w) {
        Height = h;
        Width = w;
    }
}
static void Main(string[] args) {
    Box b1 = new Box(14, 3);
    Box b2 = new Box(5, 7);
}
</pre>
</div>

<p>
Teniendo dos objetos tipo <code>Box</code> si quisiéramos sumarlos para tener un objeto <code>Box</code> más grande haríamos.
</p>

<div class="org-src-container">

<pre class="src src-csharp">Box b3 = b1 + b2;
</pre>
</div>

<blockquote>
<p>
Este comportamiento lo lograriamos a través de la sobrecarga de operadores.
</p>
</blockquote>

<ul class="org-ul">
<li>Son métodos con nombres especiales, donde la palabra <code>operator</code> va antes que el operador a definir.
</li>
<li>Similar a cualquier otro método, tienen tipos de retorno y una lista de parametros.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">public static Box operator+ (Box a, Box b) {
    int h = a.Height + b.Height;
    int w = a.Width + b.Width;
    Box res = new Box(h, w);
    return res;
}
</pre>
</div>

<blockquote>
<p>
En el ejemplo estamos sobrecargando el operador <code>+</code> para objetos de nuestra clase <code>Box</code>.
</p>
</blockquote>

<blockquote>
<p>
Todos los operadores sobrecargados deben ser estáticos.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-csharp">class Box {
    public int Height { get; set; }
    public int Width { get; set; }
    public Box(int h, int w) {
        Height = h;
        Width = w;
    }
    public static Box operator+(Box a, Box b) {
        int h = a.Height + b.Height;
        int w = a.Width + b.Width;
        Box res = new Box(h, w);
        return res;
    }
}

static void Main(string[] args)
{
    Box b1 = new Box(14, 3);
    Box b2 = new Box(5, 7);
    Box b3 = b1 + b2;

    Console.WriteLine(b3.Height);// 19
    Console.WriteLine(b3.Width);// 10
}
</pre>
</div>

<blockquote>
<p>
Podemos sobrecargar todos los operadores aritméticos y de comparación.
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Herencia y polimorfismo</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> Herencia</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>Nos permite definir una clase basada en otra clase.
</li>
<li>La clase que hereda sus propiedades a otra es llamada <b>clase base</b>.
<ul class="org-ul">
<li>La clase a la que se hereda es llamada <b>clase derivada</b>.
</li>
</ul>
</li>
<li>Podemos definir una clase <code>Animal</code> con ciertas propiedades y usarla para construir las clases <code>Perro</code> y <code>Gato</code>.
<ul class="org-ul">
<li>Estas heredan todas las propiedades de la clase animal y pueden tener sus propias propiedades.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Animal {
    public int Legs {get; set;}
    public int Age {get; set;}
}
</pre>
</div>

<blockquote>
<p>
Podemos tener nuestra clase <code>Animal</code> que será nuestra clase base.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-csharp">class Dog : Animal {
    public Dog() {
        Legs = 4;
    }
    public void Bark() {
        Console.Write("Woof");
    }
}
</pre>
</div>

<blockquote>
<p>
Y con ella crear nuestra clase <code>Dog</code>, usando sus miembros y agregando unos propios de la clase nueva.
</p>
</blockquote>

<ul class="org-ul">
<li>Debemos definir la clase y con dos puntos después del nombre definir la clase base de nuestra clase.
</li>
<li>Todos los miembros públicos de la clase <code>Animal</code> se vuelven miembros públicos de la clase <code>Dog</code>, incluyendo métodos.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">static void Main(string[] args)
    {
        Dog d = new Dog();
        Console.WriteLine(d.legs); // 4
        d.Bark();
    }
</pre>
</div>

<blockquote>
<p>
Esto nos permite reusar código ya escrito sin necesidad de reescribir.
</p>
</blockquote>

<blockquote>
<p>
C# no soporta herencia múltiple, asi que no puedes heredar de varias clases al mismo tiempo.
</p>

<p>
Sin embargo, puedes usar <b>interfaces</b> para implementar herencia múltiple.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> Miembros protegidos</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li>El modificador <code>protected</code> es parecido a <code>private</code>.
<ul class="org-ul">
<li>La diferencia es que <code>protected</code> puede ser accedido desde las clases derivadas.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Person {
    protected int Age {get; set;}
    protected string Name {get; set;}
}

class Student : Person {
    public Student(string nm) {
        Name = nm;
    }
    public void Speak() {
        Console.Write("Name: " + Name);
    }
}

static void Main(string[] args)
{
    Student s = new Student("David");
    s.Speak(); // Name: David
}
</pre>
</div>

<blockquote>
<p>
En el ejemplo podemos acceder y modificar la propiedad <code>name</code>, desde la clase derivada.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-csharp">static void Main(string[] args)
{
    Student s = new Student("David");
    s.Name = "Bob"; // Error!
}
</pre>
</div>

<blockquote>
<p>
Si intentamos acceder a ella desde afuera de la clase obtendremos un error.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> Sellado</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li>Podemos prevenir a las clases de heredar sus miembros usando el modificador <code>sealed</code>.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">sealed class Animal {
    //some code
}
class Dog : Animal { } //Error

static void Main(string[] args)
{

}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> Constructor y destructor de la clase derivada.</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li>Cada que se instancia un objeto se llama a su constructor y cada que se destruye se llama a su destructor.
</li>
<li>Con la herencia, la clase heredada no hereda el constructor y el destructor de la clase base.
<ul class="org-ul">
<li>Así que debes definir siempre unos nuevos cada que creas una clase heredada
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Animal {
    public Animal() {
        Console.WriteLine("Animal created");
    }
    ~Animal() {
        Console.WriteLine("Animal deleted");
    }
}

class Dog: Animal {
    public Dog() {
        Console.WriteLine("Dog created :D");
    }
    ~Dog() {
        Console.WriteLine("Dog deleted :c");
    }
}

static void Main(string[] args)
{
    Dog d = new Dog();
}
// Resultando en:
//Animal created
//Dog created
//Dog deleted
//Animal deleted
</pre>
</div>

<blockquote>
<p>
Cuando se crea el objeto <code>Dog</code> llamamos primero a el constructor de la clase <code>Animal</code> y después al de la clase <code>Dog</code>, y con los destructores pasa lo mismo.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5"><span class="section-number-3">7.5</span> Poliformismo</h3>
<div class="outline-text-3" id="text-7-5">
<ul class="org-ul">
<li>La palabra significa &ldquo;Tener muchas formas&rdquo;.
</li>
<li>Significa que un método puede tener muchas implementaciones diferentes.
</li>
<li>Suponiendo que nuestro programa tiene un método <code>Draw</code>, y que necesitamos dibujar muchas formas diferentes.
<ul class="org-ul">
<li>Podemos usar polimorfismo para llamar al método <code>Draw</code> correcto de cualquier clase derivada.
</li>
<li>Estos métodos deben de llevar la palabra <code>virtual</code> en la clase base.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Shape {
    public virtual void Draw() {
        Console.Write("Base Draw");
    }
}
</pre>
</div>

<blockquote>
<p>
La palabra <code>virtual</code>, permite al método ser sobre escrito en la clase derivada.
</p>
</blockquote>

<blockquote>
<p>
Los métodos virtuales nos permiten trabajar con grupos de objetos relacionados en una manera uniforme.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-csharp">class Circle : Shape {
    public override void Draw() { // &lt;-- Llevan la palabra override en la clase derivada.
        // draw a circle...
        Console.WriteLine("Circle Draw");
    }
}
class Rectangle : Shape {
    public override void Draw() {
        // draw a rectangle...
        Console.WriteLine("Rect Draw");
    }
}
</pre>
</div>

<blockquote>
<p>
Ahora podemos usar el método para sobre escribirlo y adecuarlo a lo que necesitamos.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-csharp">static void main(string[] args)
    {
        Shape c = new Circle();
        c.Draw();

        Shape r = new Rectangle();
        r.Draw();
    }
</pre>
</div>

<blockquote>
<p>
Cada instancia llama a su propio método <code>Draw</code> gracias al polimorfismo.
</p>
</blockquote>

<p>
Para resumir, el polimorfismo es una manera de llamar al mismo método para diferentes objetos y generar resultados diferentes
basados en el tipo de objeto, esto se logra mediante métodos virtuales en la clase base.
</p>


<p>
Para implementar esto, creamos objetos del tipo de la clase base pero los instanciamos con el tipo de la clase derivada.
</p>

<div class="org-src-container">

<pre class="src src-csharp">Shape c = new Circle();
</pre>
</div>

<p>
Podríamos solo instanciar cada objeto con su tipo y llamar a su método también.
</p>

<div class="org-src-container">

<pre class="src src-csharp">Circle c = new Circle();
c.Draw();
</pre>
</div>

<p>
Pero, hacerlo con polimorfismo nos trae algunas ventajas.
</p>
<ul class="org-ul">
<li>Nos permite tratar a los objetos de la misma manera.
<ul class="org-ul">
<li>Debido a que todos son objetos tipo <code>Shape</code>, es más fácil mantenerlos y trabajar con ellos.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7-6" class="outline-3">
<h3 id="sec-7-6"><span class="section-number-3">7.6</span> Clases abstractas</h3>
<div class="outline-text-3" id="text-7-6">
<ul class="org-ul">
<li>Así como el polimorfismo es logrado con métodos virtuales que son <code>overridden</code> en la clase derivada.
</li>
<li>En algunas situaciones no es necesario que el método virtual tenga una definición separada de la clase base.
</li>
<li>Estos métodos son definidos usando la palabra <code>abstract</code>.
<ul class="org-ul">
<li>Con esto se especifica que las clases derivadas deben definir ese método por su cuenta.
<ul class="org-ul">
<li>No puedes crear objetos de una clase que tiene métodos abstractos, por esa misma razón, la clase misma debe de ser abstracta.
</li>
</ul>
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">abstract class Shape {
    public abstract void Draw();
}
</pre>
</div>

<ul class="org-ul">
<li>El método <code>Draw</code> es abstracto, entonces no tiene cuerpo, no lo necesita puedes terminar la linea con un <code>;</code>.
</li>
<li>Y la clase debe de ser abstracta porque tiene un método abstracto.
</li>
</ul>

<p>
Una clase abstracta se hace para ser la base de otras clases, actúa como una plantilla para otras clases.
</p>

<div class="org-src-container">

<pre class="src src-csharp">abstract class Shape {
    public abstract void Draw();
}
class Circle : Shape {
    public override void Draw() {
        Console.WriteLine("Circle Draw");
    }
}
class Rectangle : Shape {
    public override void Draw() {
        Console.WriteLine("Rect Draw");
    }
}
static void Main(string[] args)
{
    Shape c = new Circle();
    c.Draw(); // Circle Draw
}
</pre>
</div>

<blockquote>
<p>
Ahora teniendo la clase abstracta, podemos usarla y definir su propio método <code>Draw</code>.
</p>
</blockquote>

<ul class="org-ul">
<li>Las clases abstractas tienen las siguientes características:
<ul class="org-ul">
<li>No pueden ser instanciadas.
</li>
<li>Puede contener métodos abstractos y <code>accesors</code>.
</li>
<li>Una clase no abstracta derribada de una clase abstracta debe de implementaciones de todos los miembros heredados.
</li>
</ul>
</li>
</ul>

<blockquote>
<p>
No es posible modificar una clase abstracta con la palabra <code>sealed</code>, porque son contrarios.
</p>


<p>
El modificador <code>sealed</code> previene una clase de ser heredada y el modificador <code>abstract</code> requiere que una clase sea heredada.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-7-7" class="outline-3">
<h3 id="sec-7-7"><span class="section-number-3">7.7</span> Interfaces</h3>
<div class="outline-text-3" id="text-7-7">
<ul class="org-ul">
<li>Una interfaz es una clase completamente abstracta, que contiene <b>solo</b> miembros abstractos.
</li>
<li>Es declarada usando la palabra <code>interface</code>.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">public interface IShape {
    void Draw();
}
</pre>
</div>

<ul class="org-ul">
<li>Todos los miembros de la interfaz son abstractos por defecto, así que no hay necesidad de poner la palabra.
</li>
<li>Las interfaces son públicas (por defecto), pero pueden ser privadas o protegidas.
</li>
</ul>

<blockquote>
<p>
Es común usar la letra &rsquo;I&rsquo; mayúscula al inicio del nombre de la interfaz.
</p>
</blockquote>

<blockquote>
<p>
Pueden contener propiedades, métodos, etc, pero no pueden contener campos (variables).
</p>
</blockquote>

<ul class="org-ul">
<li>Cuando una clase implementa una interfaz, debe implementar o definir todos sus métodos.
<ul class="org-ul">
<li>El termino &ldquo;Implementar una interfaz&rdquo;, es usado para describir el proceso de, crear una clase basada en una interfaz.
</li>
</ul>
</li>
<li>La interfaz describe solamente que es lo que debe de hacer una clase.
<ul class="org-ul">
<li>La clase implementando la interfaz debe definir como cumplir esos comportamientos.
</li>
</ul>
</li>
<li>La sintaxis para implementar una interfaz es la misma que para derivar una clase.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">public interface IShape {
    void Draw();
}

class Circle : IShape {
    public void Draw() {
        Console.WriteLine("Circle Draw");
    }
}

static void Main(string[] args) {
    IShape c = new Circle();
    c.Draw();
}
</pre>
</div>

<blockquote>
<p>
La palabra <code>override</code> no es necesaria cuando implementas una interfaz.
</p>
</blockquote>

<ul class="org-ul">
<li>¿Porque usar interfaces en lugar de clases abstractas?
<ul class="org-ul">
<li>Una clase puede heredar de una sola clase base, pero puede implementar muchas interfaces.
</li>
</ul>
</li>
<li>Usando interfaces puedes incluir comportamientos de distintas clases en una clase.
<ul class="org-ul">
<li>Para implementar muchas interfaces estas se separan usando comas cuando creas la clase.
<ul class="org-ul">
<li><code>class A : IShape, IAnimal, etc...</code>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-sec-7-7-1" class="outline-4">
<h4 id="sec-7-7-1"><span class="section-number-4">7.7.1</span> Implementación por defecto</h4>
<div class="outline-text-4" id="text-7-7-1">
<ul class="org-ul">
<li>La implementación por defecto en una interfaz nos permite escribir una implementación de cualquier método.
</li>
<li>Esto es útil cuando necesitamos proveer una sola implementación para un funcionamiento común.
</li>
</ul>

<p>
Digamos que queremos añadir una nueva funcionalidad común a una interfaz ya existente, la cual es implementada
por muchas clases.
</p>

<p>
Sin la implementación por defecto (antes de C# 8), esta operación provocaría errores, porque el método que agregamos
no esta implementado en la clase, la implementación por defecto resuelve este problema.
</p>

<div class="org-src-container">

<pre class="src src-csharp">public interface IShape {
    void Draw();
    void Finish() {
        Console.WriteLine("Done!");
    }
}
class Circle : IShape {
    public void Draw() {
        Console.WriteLine("Circle Draw");
    }
}
static void Main(string[] args)
{
    IShape c = new Circle();
    c.Draw(); // Circle Draw
    c.Finish(); // Done!
}
</pre>
</div>

<ul class="org-ul">
<li>Agregamos el método <code>Finish()</code> con la implementación por defecto en nuestra interfaz, y la llamamos sin implementarla en la clase <code>Circle</code>.
</li>
</ul>

<blockquote>
<p>
Métodos con la implementación por defecto pueden ser sobre escritos libremente dentro de la clase que implementa esa interfaz.
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-sec-7-8" class="outline-3">
<h3 id="sec-7-8"><span class="section-number-3">7.8</span> Clases anidadas</h3>
<div class="outline-text-3" id="text-7-8">
<ul class="org-ul">
<li>C# soporta clases anidadas.
<ul class="org-ul">
<li>Una clase que es miembro de otra clase.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Car {
    string name;
    public Car(string nm) {
        name = nm;
        Motor m = new Motor();
    }
    public class Motor {
        // some code
    }
}
</pre>
</div>

<ul class="org-ul">
<li>La clase <code>Motor</code> esta dentro de la clase <code>Car</code> y puede ser usada de la misma manera a otros miembros de la clase.
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-7-9" class="outline-3">
<h3 id="sec-7-9"><span class="section-number-3">7.9</span> <code>namespaces</code></h3>
<div class="outline-text-3" id="text-7-9">
<p>
Cuando creas un proyecto, tiene una estructura parecida a la siguiente.
</p>

<div class="org-src-container">

<pre class="src src-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Learn {
    class Program {
        static void Main(string[] args) {

        }
    }
}
</pre>
</div>

<ul class="org-ul">
<li>Todo el Programa esta dentro de un <code>namespace</code>
<ul class="org-ul">
<li>Declaran un ámbito (scope) que contiene un conjunto de objetos relacionados.
</li>
<li>Se pueden usar para organizar elementos de código.
<ul class="org-ul">
<li>Puesdes definir tus propios <code>namespaces</code> y usarlos en tu programa.
</li>
</ul>
</li>
</ul>
</li>
<li>La palabra <code>using</code> declara que el programa esta usando un <code>namespace</code>.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">using System;
// ...
Console.WriteLine("Hi");
</pre>
</div>

<blockquote>
<p>
El <code>namespace</code> <code>System</code> es donde la clase <code>Console</code> esta declarada.
</p>
</blockquote>

<p>
Si no usamos <code>using</code> tenemos que especificar el <code>namespace</code>.
</p>

<div class="org-src-container">

<pre class="src src-csharp">System.Console.WriteLine("Hi");
</pre>
</div>

<blockquote>
<p>
El .NET Framework usa <code>namespaces</code> para organizar sus clases, siendo <code>System</code> un ejemplo de esto.
</p>
</blockquote>

<blockquote>
<p>
Declarar tus propios <code>namespaces</code> puede ayudar a agrupar tus clases y métodos en proyectos grandes.
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> <code>Structs</code>, <code>Enums</code>, Excepciones &amp; Archivos</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> <code>Structs</code></h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li>Es un tipo de valor que es usado típicamente para encapsular pequeños grupos de variables relacionadas.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">struct book {
    public string title;
    public double price;
    public string author;
}
</pre>
</div>

<ul class="org-ul">
<li>Comparten la mayoría de las sintaxis con las clases, pero están más limitadas que estas.
</li>
<li>Los <code>structs</code> pueden ser instanciados sin usar el operador <code>new</code>.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">static void main(string[] args) {
    Book b;
    b.title = "Test";
    b.price = 5.99;
    b.author = "David";

    Console.WriteLine(b.title);
}
</pre>
</div>

<blockquote>
<p>
No soportan herencia y no pueden contener métodos virtuales.
</p>
</blockquote>

<ul class="org-ul">
<li><code>structs</code> pueden contener:
<ul class="org-ul">
<li>Métodos.
</li>
<li>Propiedades.
</li>
<li>Indexadores.
</li>
<li>Etc.
</li>
</ul>
</li>
<li>No pueden contener constructores por defecto (Constructores sin parametros).
<ul class="org-ul">
<li>Pero pueden contener constructores que toman parametros.
<ul class="org-ul">
<li>Si los usan, la palabra <code>new</code> es necesaria para instanciarlos de manera similar a una clase.
</li>
</ul>
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">struct Point {
    public int x;
    public int y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
public void Main(string[] args) {
    Point p = new Point(10, 15);
    Console.WriteLine(p.x);
}
</pre>
</div>
</div>

<div id="outline-container-sec-8-1-1" class="outline-4">
<h4 id="sec-8-1-1"><span class="section-number-4">8.1.1</span> <code>Structs</code> vs Clases</h4>
<div class="outline-text-4" id="text-8-1-1">
<ul class="org-ul">
<li>Las clases son usadas para modelar comportamientos más complejos o datos que están destinados a ser modificados después de que se crea el objeto.
</li>
<li>Los <code>structs</code> son mejores para estructuras de datos pequeñas que contienen datos que no están destinados a cambiar después de crearse.

<blockquote>
<p>
Todos los tipos de datos por defecto en C# son <code>structs</code> (int, double, bool, char, etc).
</p>
</blockquote>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> <code>Enums</code></h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>La parabra <code>enum</code> es usada para declarar una enumeración.
<ul class="org-ul">
<li>Un tipo que consiste de un conjunto de constantes llamadas la lista del enumerador.
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};
</pre>
</div>

<p>
Puedes también asignar tus propios valores al <code>enum</code>.
</p>

<div class="org-src-container">

<pre class="src src-csharp">enum Days {Sun, Mon, Tue=4, Wed, Thu, Fri, Sat};
</pre>
</div>

<ul class="org-ul">
<li>En el ejemplo de arriba, la enumeración empieza desde 0, siendo 1 Mon, y Tue 4 Wed 5 y asi, respetando los valores dados.
</li>
<li>Podemos acceder a los elementos de un <code>enum</code> con la sintaxis de punto.
</li>
<li>Para asignar los valores de un enum a variables necesitamos especificar el tipo entre parentesis.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};

static void Main(string[] args) {
    int x = (int)Days.Tue;
    Console.WriteLine(x);
}
</pre>
</div>

<blockquote>
<p>
<code>enums</code> definen variables que pertenecen a un conjunto fijo, como lo pueden ser los meses del año o los días de la semana.
</p>
</blockquote>

<p>
Estos son usados en conjunto con <code>switch</code>
</p>

<div class="org-src-container">

<pre class="src src-csharp">enum TrafficLights { Green, Red, Yellow };

static void Main(string[] args) {
    TrafficLights x = TrafficLights.Red;
    switch (x) {
        case TrafficLights.Green:
            Console.WriteLine("Go!");
            break;
        case TrafficLights.Red:
            Console.WriteLine("Stop!");
            break;
        case TrafficLights.Yellow:
            Console.WriteLine("Go faster!");
            break;
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> Manejo de excepciones</h3>
<div class="outline-text-3" id="text-8-3">
<ul class="org-ul">
<li>Una excepción es un problema que ocurre durante la ejecución de un programa.
<ul class="org-ul">
<li>Estas causan que el programa termine de manera anormal.
</li>
</ul>
</li>
<li>Estas pueden suceder por muchas razones, desde datos inválidos hasta fallas de lógica.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int[] arr = new int[] {4, 6, 8};
Console.WriteLine(arr[8]);
</pre>
</div>

<blockquote>
<p>
Este código causara una excepción porque estamos intentando acceder a un valor que no existe.
</p>
</blockquote>

<ul class="org-ul">
<li>C# nos provee una manera de manejar estas excepciones con un <code>try-catch</code>.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">try {
    int[] arr = new int[] {4, 6, 8};
    Console.WriteLine(arr[8]);
}
catch(Exeption e) {
    Console.Writeline("Un error ha ocurrido.")
}
</pre>
</div>

<ul class="org-ul">
<li>El código que puede detonar una excepción se pone dentro del bloque <code>try</code>.
<ul class="org-ul">
<li>Si una excepción ocurre, se ejecuta el bloque <code>catch</code> sin que el programa pare de manera abrupta.
</li>
</ul>
</li>
<li>Dentro del bloque <code>catch</code> entre parentesis se pone el tipo de excepción que queremos manejar, pero podemos usar la palabra <code>Exeption</code> para manejar cualquier excepción.
</li>
<li>La excepción 
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">try {
    int[] arr = new int[] {4, 6, 8};
    Console.WriteLine(arr[8]);
}
catch(Exeption e) {
    Console.Writeline(e.Message);
}
</pre>
</div>
</div>

<div id="outline-container-sec-8-3-1" class="outline-4">
<h4 id="sec-8-3-1"><span class="section-number-4">8.3.1</span> Manejando diferentes excepciones</h4>
<div class="outline-text-4" id="text-8-3-1">
<ul class="org-ul">
<li>Podemos incluir diferentes bloques <code>catch</code> para cada <code>try</code> para tener comportamientos personalizados para cada exceppción.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int x, y;
try {
    x = Convert.ToInt32(Console.Read());
    y = Convert.ToInt32(Console.Read());
    Console.WriteLine(x / y);
}
catch (DivideByZeroException e) {
    Console.WriteLine("Cannot divide by 0");
}
catch(Exception e) {
    Console.WriteLine("An error occurred");
}
</pre>
</div>

<blockquote>
<p>
Las excepciones son muy útiles cuando manejamos input del usuario para validar la información que es dada al programa.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-8-3-2" class="outline-4">
<h4 id="sec-8-3-2"><span class="section-number-4">8.3.2</span> <code>Finally</code></h4>
<div class="outline-text-4" id="text-8-3-2">
<ul class="org-ul">
<li><code>finally</code> es un bloque que pone al final de los bloques <code>catch</code> y siempre se ejecuta, sin importar si una excepción ocurre o no.
</li>
<li>Es útil para cerrar archivos o conexiones, ya que siempre se tienen que cerrar sin importar si un error ocurre o no.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">int result=0;
int num1 = 8;
int num2 = 4;
try {
    result = num1 / num2;
}
catch (DivideByZeroException e) {
    Console.WriteLine("Error");
}
finally {
    Console.WriteLine(result);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> Trabajando con archivos</h3>
<div class="outline-text-3" id="text-8-4">
<ul class="org-ul">
<li>El <code>namespace</code> <code>System.IO</code> tiene varias clases para trabajar con archivos.
</li>
<li>La clase <code>File</code> es una de ellos.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">string str = "Some text";
File.WriteAllText("test.txt", str);
</pre>
</div>

<ul class="org-ul">
<li>El método <code>WriteAllText</code> crea un archivo en la ruta especificada y escribe su contenido en el.
<ul class="org-ul">
<li>Si el archivo existe lo sobre escribe.
</li>
</ul>
</li>
<li>Podemos Leer el contenido de un archivo usando <code>ReadAllText</code>.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">string text = File.ReadAllText("test.txt");
Console.WriteLine(text);
</pre>
</div>

<ul class="org-ul">
<li>La clase File tiene también otros métodos.
<ul class="org-ul">
<li><code>AppendAllText()</code>
</li>
<li><code>Create()</code>
</li>
<li><code>Delete()</code>
</li>
<li><code>Exists()</code>
</li>
<li><code>Copy()</code>
</li>
<li><code>Move()</code>
</li>
</ul>
</li>
<li>Todos estos métodos cierran el archivo cuando terminan de ejecutarse.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Genéricos</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> Genéricos</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li>Los genéricos nos permiten rehusar código con diferentes tipos.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">static void Swap(ref int a, ref int b) {
    int temp = a;
    a = b;
    b = temp;
}
</pre>
</div>

<blockquote>
<p>
En el código de arriba tenemos un método que cambia de lugar dos valores.
</p>
</blockquote>

<p>
Este código solo funciona con enteros, si queremos usarlo con otros tipos deberemos sobrecargarlo con todos los tipos que querramos usarlo.
</p>

<ul class="org-ul">
<li>Con los genéricos podemos definir un tipo de dato genérico.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">static void Swap&lt;T&gt;(ref T a, ref T b) {
    T temp = a;
    a = b;
    b = temp;
}
</pre>
</div>

<blockquote>
<p>
<code>T</code> es el nombre de nuestro tipo genérico y se define con <code>&lt;T&gt;</code>.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> Métodos Genéricos</h3>
<div class="outline-text-3" id="text-9-2">
<ul class="org-ul">
<li>Ahora podemos definir nuestro método <code>Swap</code> con diferentes tipos de datos.
</li>
<li>Cuando llamemos a un método genérico debemos de especificar el tipo de dato con el que vamos a trabajar.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">static void Swap&lt;T&gt;(ref T a, ref T b) {
    T temp = a;
    a = b;
    b = temp;
}
static void Main(string[] args) {
    int a = 4, b = 9;
    Swap&lt;int&gt;(ref a, ref b);
    Console.WriteLine(a+" "+b);

    string x = "Hello";
    string y = "World";
    Swap&lt;string&gt;(ref x, ref y);
    Console.WriteLine(x+" "+y);
}
</pre>
</div>

<blockquote>
<p>
Podemos tener múltiples parametros de diferente tipo en un método genérico usando <code>&lt;T,U&gt;</code>.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3"><span class="section-number-3">9.3</span> Clases genéricas</h3>
<div class="outline-text-3" id="text-9-3">
<ul class="org-ul">
<li>Los tipos genéricos también pueden ser usados con clases.
</li>
<li>El uso más común para clases genéricas es con collecciones de elementos.
<ul class="org-ul">
<li>En estos las operaciones básicas como suma o resta se hacen sin importar que tipo de elemento sea.
</li>
</ul>
</li>
<li>Podemos hacer una implementación de una pila genérica.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">class Stack&lt;T&gt; {
    int index=0;
    T[] innerArray = new T[100];

    public void Push(T item) {
        innerArray[index++] = item;
    }

    public T Pop() {
        return innerArray[--index];
    }

    public T Get(int k) { return innerArray[k]; }
}
</pre>
</div>

<ul class="org-ul">
<li>Nuestra implementación de una pila genérica guarda elementos de cualquier tipo.
</li>
<li>Así que podemos crear objetos de nuestra clase genérica.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">Stack&lt;int&gt; intStack = new Stack&lt;int&gt;();
Stack&lt;string&gt; strStack = new Stack&lt;string&gt;();
Stack&lt;Person&gt; PersonStack = new Stack&lt;Person&gt;();
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-9-4" class="outline-3">
<h3 id="sec-9-4"><span class="section-number-3">9.4</span> Colecciones</h3>
<div class="outline-text-3" id="text-9-4">
<ul class="org-ul">
<li>Son usadas para agrupar objetos relacionados entre si.
</li>
<li>A diferencia de un arreglo, estos son dinámicos.
</li>
<li>Típicamente incluyen métodos para agregar, remover o contar los elementos dentro de ellas.
</li>
<li>Se puede iterar a través de ellas con <code>for</code>, <code>foreach</code>.
</li>
<li>Como son clases, debes de declarar una instancia de esta antes de añadir elementos a esta.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-csharp">List&lt;int&gt; li = new List&lt;int&gt;();
</pre>
</div>
</div>

<div id="outline-container-sec-9-4-1" class="outline-4">
<h4 id="sec-9-4-1"><span class="section-number-4">9.4.1</span> Colecciones genéricas</h4>
<div class="outline-text-4" id="text-9-4-1">
<ul class="org-ul">
<li>Son el tipo de colección a usar siempre que todos los elementos sean del mismo tipo.
</li>
<li>El <code>namespace</code> <code>System.Collections.Generic</code> incluye las siguentes collecciones genéricas.
<ul class="org-ul">
<li><code>List&lt;T&gt;.</code>
</li>
<li><code>Dictionary&lt;TKey,TValue&gt;.</code>
</li>
<li><code>SortedList&lt;TKey,TValue&gt;.</code>
</li>
<li><code>Stack&lt;T&gt;.</code>
</li>
<li><code>Queue&lt;T&gt;.</code>
</li>
<li><code>Hashset&lt;T&gt;.</code>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-9-4-2" class="outline-4">
<h4 id="sec-9-4-2"><span class="section-number-4">9.4.2</span> Colecciones no genéricas</h4>
<div class="outline-text-4" id="text-9-4-2">
<ul class="org-ul">
<li>Guardan elementos que son de tipo <code>Object</code>.
</li>
<li>Pueden ser más lentas que las genéricas.
</li>
<li>El <code>namespace</code> <code>System.Collections</code> incluye las siguentes collecciones no genéricas.
<ul class="org-ul">
<li><code>ArrayList</code>
</li>
<li><code>SortedList</code>
</li>
<li><code>Stack</code>
</li>
<li><code>Queue</code>
</li>
<li><code>Hashtable</code>
</li>
<li><code>BitArray</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-9-5" class="outline-3">
<h3 id="sec-9-5"><span class="section-number-3">9.5</span> <code>List</code> y <code>BitArray</code></h3>
<div class="outline-text-3" id="text-9-5">
<ul class="org-ul">
<li>Una lista es similar a un arreglo, pero en esta los elementos pueden ser agregados y removidos de manera dinámica.
</li>
<li>Requiere que todos los elementos sean del mismo tipo.
</li>
<li>Incluye los siguientes métodos:
<dl class="org-dl">
<dt> <code>Count</code> </dt><dd>Obtiene el número de elementos que contiene la lista.
</dd>
<dt> <code>Add</code> </dt><dd>Añade un elemento al final de la lista.
</dd>
<dt> <code>RemoveAt(int index)</code> </dt><dd>Remueve un elemento en el índice dado.
</dd>
<dt> <code>Sort()</code> </dt><dd>Ordena los elementos de la lista.
</dd>
<dt> <code>Capacity</code> </dt><dd>Obtiene el número de elementos que la lista puede tener antes de cambiar de tamaño.
</dd>
<dt> <code>Clear()</code> </dt><dd>Remueve los elementos de la lista.
</dd>
<dt> <code>TrimExess()</code> </dt><dd>Pone la capacidad de la lista a el número actual de elementos, útil para reducir memoria.
</dd>
<dt> <code>AddRange(IEnumerable coll)</code> </dt><dd>Añade los elementos de una collección con los elementos del mismo tipo de la lista al final de esta.
</dd>
<dt> <code>Insert(int i, T t)</code> </dt><dd>Inserta el elemento t en el índice i.
</dd>
<dt> <code>Remove(T t)</code> </dt><dd>Remueve la primera ocurrencia de el elemento t en la lista.
</dd>
<dt> RemoveRange(int i, int count) </dt><dd>Remueve un rango de elementos de la lista.
</dd>
<dt> <code>Contains(T t)</code> </dt><dd>Retorna <code>true</code> si el elemento especificado existe en la lista.
</dd>
<dt> <code>Reverse()</code> </dt><dd>Invierte el orden de los elementos en la lista.
</dd>
<dt> <code>ToArray()</code> </dt><dd>Copia los elementos de la lista en un nuevo arreglo.
</dd>
</dl>
</li>
</ul>
</div>

<div id="outline-container-sec-9-5-1" class="outline-4">
<h4 id="sec-9-5-1"><span class="section-number-4">9.5.1</span> <code>SortedList</code></h4>
<div class="outline-text-4" id="text-9-5-1">
<ul class="org-ul">
<li>Es una colección de valores tipo llave/valor.
<ul class="org-ul">
<li>Son ordenados por la llave.
</li>
<li>La llave puede ser usada para acceder al valor.
</li>
</ul>
</li>
<li>Requiere que los elementos llave/valor sean del mismo tipo.
</li>
<li>Las llaves no pueden repetirse.
</li>
<li>Incluye los siguientes métodos.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-9-5-2" class="outline-4">
<h4 id="sec-9-5-2"><span class="section-number-4">9.5.2</span> <code>BitArray</code></h4>
<div class="outline-text-4" id="text-9-5-2">
<ul class="org-ul">
<li>Son una colección de bits.
<ul class="org-ul">
<li>Sus valores pueden ser 0 o 1.
</li>
</ul>
</li>
<li>Normalmente son usados para representar un grupo de banderas booleanas.
</li>
<li>Contiene las siguentes propiedades y métodos:
<dl class="org-dl">
<dt> <code>Count</code> </dt><dd>Obtiene el número de bits en el arreglo.
</dd>
<dt> <code>IsReadOnly</code> </dt><dd>Obtiene un valor indicando si el <code>BitArray</code> es de solo lectura.
</dd>
<dt> <code>SetAll(bool value)</code> </dt><dd>Pone todos los valores del arreglo en un valor especifico.
</dd>
<dt> <code>And(BitArray ba)</code> </dt><dd>Aplica un <code>and</code> al <code>BitArray</code> dado con el valor <code>ba</code>.
<ul class="org-ul">
<li>También puedes hacer <code>Or, Xor</code>.
</li>
</ul>
</dd>
<dt> <code>Not()</code> </dt><dd>Invierte los valores del <code>BitArray</code>.
</dd>
</dl>
</li>
<li>Los <code>BitArray</code> pueden usarse para el procesamiento de imágenes.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-9-6" class="outline-3">
<h3 id="sec-9-6"><span class="section-number-3">9.6</span> <code>Stack</code> y <code>Queue</code></h3>
<div class="outline-text-3" id="text-9-6">
<ul class="org-ul">
<li>Una pila (stack) es una lista tipo <b>last in, first out</b> (LIFO).
</li>
<li>Insertar un elemento a un stack es llamado <code>pushing</code>.
</li>
<li>Quitar un elemento del stack es llamado <code>pop</code>.
<ul class="org-ul">
<li>Esto solo puede hacerse en la parte superior del stack.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-9-7" class="outline-3">
<h3 id="sec-9-7"><span class="section-number-3">9.7</span> <code>HashSet</code></h3>
<div class="outline-text-3" id="text-9-7">
<ul class="org-ul">
<li>Es un conjunto de valores únicos.
</li>
<li>Estos son diferentes a otras colecciones porque solo son un conjunto de valores, no tienen índice.
</li>
</ul>

<blockquote>
<p>
Los HashSet proveen un alto rendimiento, en la busqueda, adición y eliminación de elementos, puede ser usada para implementar otras estructuras de datos.
</p>
</blockquote>
</div>
</div>
</div>
</div></div></div>
<footer id="postamble" class="">
<div><p class="author">Author: J.D Castro</p>
<p class="date">Created: 2022-01-30 Sun 21:51</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 28.0.91 (<a href="http://orgmode.org">Org-mode</a> 9.6)</p>
</div>
</footer>
</body>
</html>
